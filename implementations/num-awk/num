#!/bin/sh
set -euf

##
# Num: number utilties for mathematics and statistics.
#
# Syntax:
#
#     num [ options ] [ file ... ]
#
# Full documentation is available in the GitHub repository:
# https://github.com/numcommand/num
#
# ## Tracking
#
# Author: Joel Parker Henderson (joel@joelparkerhenderson.com)
# License: GPL, BSD, MIT
# Created: 2015-03-28
# Updated: 2015-10-22
# Version: 0.3.0
##

awk '

############################################################################
#
# Public Functions
#
##

# All items.
#
function all(num, num_, options) {
    if (!("all" in num_)) {
        num_["all"] = arr_join(num, OFS)
    }
    return num_["all"]
}

# First item.
#
# Example:
#
#   1 2 4 => 1
#
function first(num, num_, options) {
    if (!("first" in num_)) {
        num_["first"] = arr_first(num)
    }
    return num_["first"]
}

# Last item.
#
# Example:
#
#   1 2 4 => 4
#
function last(num, num_, options) {
    if (!("last" in num_)) {
        num_["last"] = arr_last(num)
    }
    return num_["last"]
}

# Number of items, a.k.a. count, length.
#
# Example:
#
#     1 2 4 => 3
#
function n(num, num_, options) {
    if (!("n" in num_)) {
        num_["n"] = arr_length(num)
    }
    return num_["n"]
}

# Minimum value.
#
# Example:
#
#     1 2 4 => 1
#
function min(num, num_, options,  _min, i) {
    if (!("min" in num_)) {
        num_["min"] = arr_min_via_scan(num)  # TODO ascending/descending
    }
    return num_["min"]
}

# Maximum value.
#
# Example:
#
#     1 2 4 => 4
#
function max(num, num_, options,  _max, i) {
    if (!("max" in num_)) {
        num_["max"] = arr_max_via_scan(num)  # TODO ascending/descending
    }
    return num_["max"]
}

# Range, a.k.a. spread.
#
# Example:
#
#     1 2 4 => 3
#
function range(num, num_, options) {
    if (!("range" in num_)) {
        num_["range"] = max(num, num_, options) - min(num, num_, options)
    }
    return num_["range"]
}

# Sum, a.k.a. total.
#
# Example:
#
#     1 2 4 => 7
#
function sum(num, num_, options,  _sum, i) {
    if (!("sum" in num_)) {
        _sum = 0
        for (i in num) {
            _sum += num[i]
        }
        num_["sum"] = _sum
    }
    return num_["sum"]
}

# Mean, a.k.a. arithmetic mean, average.
#
# Example:
#
#     1 2 4 => 2.33333
#
function mean(num, num_, options) {
    if (!("mean" in num_)) {
        if (num_["linear"]){
          num_["mean"] = (max(num, num_, options) - min(num, num_, options)) / n(num, num_, options)
        } else {
          num_["mean"] = sum(num, num_, options) / n(num, num_, options)
        }
    }
    return num_["mean"]
}

# Median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 3
#
function median(num, num_, options,  _n) {
    if (!("median" in num_)) {
        asort(num)  # TODO POSIX
        _n = n(num, num_, options)
        if (_n % 2) {
            num_["median"] = num_["median_low"] = num_["median_high"] = num[(_n + 1) / 2]
        } else {
            num_["median_low"] = num[(_n / 2)]
            num_["median_high"] =  num[(_n / 2) + 1]
            num_["median"] = ((num_["median_low"] + num_["median_high"]) / 2.0)
        }
    }
    return num_["median"]
}

# Median-low: get the lesser median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 2
#
function median_low(num, num_, options,  _n) {
    if (!("median_low" in num_)) {
        median(num, num_, options)
    }
    return num_["median_low"]
}

# Median-high: get the greater median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 4
#
function median_high(num, num_, options,  _n) {
    if (!("median_high" in num_)) {
        median(num, num_, options)
    }
    return num_["median_high"]
}

# Mode: get the mode, which may be a number, or list, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 4 => 2
#     1 1 2 4 4 => 1 4
#     1 2 3 => UNDEF
#
function mode(num, num_, options) {
    if (!("mode" in num_)) {
        num_["mode"] = TODO
    }
    return num_["mode"]
}

# Mode-low: get the first mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 1
#     1 2 3 => UNDEF
#
function mode_low(num, num_, options) {
    if (!("mode_low" in num_)) {
        num_["mode_low"] = TODO
    }
    return num_["mode_low"]
}

# Mode-high: get the last mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 4
#     1 2 3 => UNDEF
#
function mode_high(num, num_, options) {
    if (!("mode_high" in num_)) {
        num_["mode_high"] = TODO
    }
    return num_["mode_high"]
}

# Sum of Squares, a.k.a. the sum of the squared deviations, a.k.a. SS.
#
# Example:
#
#     1 2 4 => 4.66667
#
function sum_of_squares(num, num_, options,  _sum, _mean, i) {
    if (!("sum_of_squares" in num_)) {
        _sum = 0
        _mean = mean(num, num_, options)
        for (i in num) {
            _sum += (num[i] - _mean) ** 2
        }
        num_["sum_of_squares"] = _sum
    }
    return num_["sum_of_squares"]
}

# Population Variance.
#
# Example:
#
#     1 2 4 => 1.55556
#
function population_variance(num, num_, options,  f) {
    f="population_variance"
    if (!(f in num_)) {
        num_[f] = sum_of_squares(num, num_, options) / n(num, num_, options)
    }
    return num_[f]
}

# Sample Variance.
#
# Example:
#
#     1 2 4 => 2.33333
#
function sample_variance(num, num_, options,  f) {
    f="sample_variance"
    if (!(f in num_)) {
        num_[f] = sum_of_squares(num, num_, options) / (n(num, num_, options) - 1)
    }
    return num_[f]
}

# Population Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.24722
#
function population_standard_deviation(num, num_, options,  f) {
    f="population_standard_deviation"
    if (!(f in num_)) {
        num_[f] = sqrt(population_variance(num, num_, options))
    }
    return num_[f]
}

# Sample Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.52753
#
function sample_standard_deviation(num, num_, options,  f) {
    f="sample_standard_deviation"
    if (!(f in num_)) {
        num_[f] = sqrt(sample_variance(num, num_, options))
    }
    return num_[f]
}

# Population Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.534522
#
function population_coefficient_of_variance(num, num_, options,  f) {
    f="population_coefficient_of_variance"
    if (!(f in num_)) {
        num_[f] = population_standard_deviation(num, num_, options) / mean(num, num_, options)
    }
    return num_[f]
}

# Sample Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.654654
#
function sample_coefficient_of_variance(num, num_, options,  f) {
    f="sample_coefficient_of_variance"
    if (!(f in num_)) {
        num_[f] = sample_standard_deviation(num, num_, options) / mean(num, num_, options)
    }
    return num_[f]
}

# Skewness
#
# Example:
#
#     TODO
#
function skewness(num, num_, options,  _mean, x, i) {
    if (!("skewness" in num_)) {
        num_["skewness"] = TODO
    }
    return num_["skewness"]
}

# Kurtosis
#
# Example:
#
#     TODO
#
function kurtosis(num, num_, options) {
    if (!("kurtosis" in num_)) {
        num_["kurtosis"] = TODO
    }
    return num_["kurtosis"]
}

# IQR
#
# Example:
#
#     TODO
#
function iqr(num, num_, options) {
    if (!("iqr" in num_)) {
        num_["iqr"] = TODO
    }
    return num_["iqr"]
}

# Q0
#
# Example:
#
#     TODO
#
function q0(num, num_, options) {
    if (!("q0" in num_)) {
        num_["q0"] = TODO
    }
    return num_["q0"]
}

# Q1
#
# Example:
#
#     TODO
#
function q1(num, num_, options) {
    if (!("q1" in num_)) {
        num_["q1"] = TODO
    }
    return num_["q1"]
}
# Q2
#
# Example:
#
#     TODO
#
function q2(num, num_, options) {
    if (!("q2" in num_)) {
        num_["q2"] = TODO
    }
    return num_["q2"]
}

# Q3
#
# Example:
#
#     TODO
#
function q3(num, num_, options) {
    if (!("q3" in num_)) {
        num_["q3"] = TODO
    }
    return num_["q3"]
}
# Q4
#
# Example:
#
#     TODO
#
function q4(num, num_, options) {
    if (!("q4" in num_)) {
        num_["q4"] = TODO
    }
    return num_["q4"]
}

############################################################################
#
# ARRAY UTILITIES
#
##

# Dump an array, suitable for debugging.
#
# Example:
#
#     arr_dump(arr)
#     1 a
#     2 b
#     3 d
#
function arr_dump(arr) {
    for (k in arr) print k, arr[k]
}

# Is an array empty?
#
# Example:
#
#   split("", arr)
#   arr_empty(arr) => TRUE
#
# This is POSIX compatible.
#
function arr_empty(arr,  i) {
    for (i in arr) return 0
    return 1
}

# Length of an array.
#
# Example:
#
#     arr_length(1 2 4) => 3
#
# TODO: Optimize - consider using `gawk` and its `length` function.
#
function arr_length(arr,  i, k) {
    for (i in arr) k++
    return k
}

# Return the first item in an array.
#
# Example:
#
#     arr_first(1 2 4) => 1
#
function arr_first(arr) {
    return arr[1]
}

# Return the last item in an array.
#
# Example:
#
#     arr_last(1 2 4) => 4
#
function arr_last(arr) {
    return arr[arr_length(arr)]
}

# Get the minimum value, by doing a scan of the entire array.
#
# Example:
#
#     arr_min_via_scan(1 2 4) => 4
#
function arr_min_via_scan(arr,  _min) {
    _min = arr[1]
    for (i in arr) if (arr[i] < _min) _min = arr[i]
    return _min
}

# Get the maxmimum value, by doing a scan of the entire array.
#
# Example:
#
#     arr_max_via_scan(1 2 4) => 4
#
function arr_max_via_scan(arr,  _max) {
    _max = arr[1]
    for (i in arr) if (arr[i] > _max) _max = arr[i]
    return _max
}

# Join an array to a string, with a separator string.
#
# Example:
#
#     arr_join(1 2 4, ",") => "1,2,4"
#
function arr_join(arr, sep,  s, i) {
    s = ""
    for (i in arr) s = s arr[i] sep
    s = substr(s, 1, length(s) - length(sep))
    return s
}

# Push one item on an array stack, by using the `length` function.
#
# Example:
#
#     arr = 1 2
#     arr_push(arr, 4)
#     => arr == 1 2 4
#
function arr_push(arr, item) {
    arr[length(arr)+1] = item
}

############################################################################
#
# INITIALIZE
#
##

# Initialize everything.
#
# This calls various `init_*` functions.
#
function init() {
    init_constants()
    init_word_argv()
    init_word_list()
}

# Initialize constants that we use; these are essentially like defines.
#
function init_constants() {
    FALSE = 0
    TRUE = 1
    TODO = "TODO"
    UNDEF = "UNDEF"
}

# Initialize the word argv list.
#
# The word argv list holds the argv items that this script cares about.
# We keep them in order, so we can output results in order.
#
function init_word_argv() {
    split("", global_word_argv)
}

# Initialize the global word list lookup array.
#
# This is to recognize words that a user types on the command line.
#
# TODO: research if there is a better way to initialize a dictionary.
#
function init_word_list() {
    global_word_list["all"] = "all"
    global_word_list["first"] = "first"
    global_word_list["last"] = "last"
    global_word_list["n"] = global_word_list["count"] = global_word_list["length"] = global_word_list["size"] = "n"
    global_word_list["first"] = "first"
    global_word_list["last"] = "last"
    global_word_list["min"] = global_word_list["minimum"] = "min"
    global_word_list["max"] = global_word_list["maximum"] = "max"
    global_word_list["range"] = global_word_list["spread"] = "range"
    global_word_list["sum"] = global_word_list["total"] = "sum"
    global_word_list["mean"] = global_word_list["average"] = global_word_list["avg"] = "mean"
    global_word_list["median"] = global_word_list["med"] = "median"
    global_word_list["median-low"] = global_word_list["medianlow"] = global_word_list["med-low"] = global_word_list["medlow"] = "median-low"
    global_word_list["median-high"] = global_word_list["medianhigh"] = global_word_list["med-high"] = global_word_list["medhigh"] = "median-high"
    global_word_list["mode"] = "mode"
    global_word_list["mode-low"] = global_word_list["modelow"] = "mode-low"
    global_word_list["mode-high"] = global_word_list["modehigh"] = "mode-high"
    global_word_list["sum-of-squares"] = global_word_list["sumofsquares"] = global_word_list["sum-squares"] = global_word_list["sumsquares"] = global_word_list["sum2"] = global_word_list["ss"] = "sum-of-squares"

    # Convention: default is sample, not population.
    global_word_list["variance"] = \
    global_word_list["var"] = \
    "sample-variance"

    global_word_list["population-variance"] = \
    global_word_list["populationvariance"] = \
    global_word_list["p-variance"] = \
    global_word_list["pvariance"] = \
    global_word_list["p-var"] = \
    global_word_list["pvar"] = \
    "population-variance"

    global_word_list["sample-variance"] = \
    global_word_list["samplevariance"] = \
    global_word_list["s-variance"] = \
    global_word_list["svariance"] = \
    global_word_list["s-var"] = \
    global_word_list["svar"] = \
    "sample-variance"

    # Convention: default is sample, not population.
    global_word_list["standard-deviation"] = \
    global_word_list["standarddeviation"] = \
    global_word_list["st-dev"] = \
    global_word_list["stdev"] = \
    global_word_list["sd"] = \
    "sample-standard-deviation"

    global_word_list["population-standard-deviation"] = \
    global_word_list["populationstandarddeviation"] = \
    global_word_list["p-st-dev"] = \
    global_word_list["pstdev"] = \
    global_word_list["p-sd"] = \
    global_word_list["psd"] = \
    "population-standard-deviation"

    global_word_list["sample-standard-deviation"] = \
    global_word_list["samplestandarddeviation"] = \
    global_word_list["s-st-dev"] = \
    global_word_list["sstdev"] = \
    global_word_list["s-sd"] = \
    global_word_list["ssd"] = \
    "sample-standard-deviation"

    # Convention: default is sample, not population.
    global_word_list["coefficient-of-variance"] = \
    global_word_list["coefficientofvariance"] = \
    global_word_list["co-var"] = \
    global_word_list["covar"] = \
    global_word_list["cv"] = \
    "sample-coefficient-of-variance"

    global_word_list["population-coefficient-of-variance"] = \
    global_word_list["populationcoefficientofvariance"] = \
    global_word_list["p-co-var"] = \
    global_word_list["pcovar"] = \
    global_word_list["p-cv"] = \
    global_word_list["pcv"] = \
    "population-coefficient-of-variance"

    global_word_list["sample-coefficient-of-variance"] = \
    global_word_list["samplecoefficientofvariance"] = \
    global_word_list["s-co-var"] = \
    global_word_list["scovar"] = \
    global_word_list["s-cv"] = \
    global_word_list["scv"] = \
    "sample-coefficient-of-variance"

    global_word_list["skewness"] = global_word_list["skew"] = "skewness"
    global_word_list["kurtosis"] = global_word_list["kurtosis"] = "kurtosis"
    global_word_list["iqr"] = "iqr"
    global_word_list["q0"] = "q0"
    global_word_list["q1"] = "q1"
    global_word_list["q2"] = "q2"
    global_word_list["q3"] = "q3"
    global_word_list["q4"] = "q4"
}


############################################################################
#
# WORDS
#
##

# Given a word, call its function.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_function(num, num_, "sum")
#     => 7 (by calling the `sum` function)
#
# Note: this implementation uses if..else instead of
# any switch or case, because we want POSIX usability.
#
# TODO: Is there a way to shorten this function,
# perhaps by reflection on the word and function name?
#
function word_to_function(num, num_, options, word) {
    if (word == "all")
        return (all(num, num_, options))
    else if (word == "first")
        return (first(num, num_, options))
    else if (word == "last")
        return (last(num, num_, options))
    else if (word == "n")
        return (n(num, num_, options))
    else if (word == "min")
        return min(num, num_, options)
    else if (word == "max")
        return max(num, num_, options)
    else if (word == "range")
        return range(num, num_, options)
    else if (word == "sum")
         return sum(num, num_, options)
    else if (word == "mean")
        return mean(num, num_, options)
    else if (word == "median")
        return median(num, num_, options)
    else if (word == "median-low")
        return median_low(num, num_, options)
    else if (word == "median-high")
        return median_high(num, num_, options)
    else if (word == "mode")
        return mode(num, num_, options)
    else if (word == "mode-low")
        return mode_low(num, num_, options)
    else if (word == "mode-high")
        return mode_high(num, num_, options)
    else if (word == "sum-of-squares")
        return sum_of_squares(num, num_, options)
    else if (word == "population-variance")
        return population_variance(num, num_, options)
    else if (word == "sample-variance")
        return sample_variance(num, num_, options)
    else if (word == "population-standard-deviation")
        return population_standard_deviation(num, num_, options)
    else if (word == "standard-deviation")
        return standard_deviation(num, num_, options)
    else if (word == "sample-standard-deviation")
        return sample_standard_deviation(num, num_, options)
    else if (word == "population-coefficient-of-variance")
        return population_coefficient_of_variance(num, num_, options)
    else if (word == "sample-coefficient-of-variance")
        return sample_coefficient_of_variance(num, num_, options)
    else if (word == "skewness")
        return skewness(num, num_, options)
    else if (word == "kurtosis")
        return kurtosis(num, num_, options)
    else if (word == "iqr")
        return iqr(num, num_, options)
    else if (word == "q0")
        return q0(num, num_, options)
    else if (word == "q1")
        return q1(num, num_, options)
    else if (word == "q2")
        return q2(num, num_, options)
    else if (word == "q3")
        return q3(num, num_, options)
    else if (word == "q4")
        return q4(num, num_, options)
    else
        return ""
}

# Given a word, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, options, "sum")
#     => "7"
#
function word_to_s(num, num_, options, word,  s) {
    s = word_to_function(num, num_, options, word)
    return s
}

# Given words, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, options, ("sum", "max"))
#     => "1 4"
#
function words_to_s(num, num_, options, words, sep,  word, i, s, s2) {
    s = ""
    for (i in words) {
        word = words[i]
        s2 = word_to_s(num, num_, options, word)
        s = s s2 sep
    }
    s = substr(s, 1, length(s) - length(sep))
    return s
}

############################################################################
#
# INPUT/OUTPUT
#
##

# Start receiving input.
#
# Ready the global number array for new input and new metadata.
#
function start_input() {
    split("", global_num)   # The input values.
    split("", global_num_)  # The metadata, such as cached results.
}

# Stop receiving input.
#
# Set any work in progress here.
#
function stop_input() {
    global_num_["n"] = global_num_n
}

# Parse word inputs by iterating: whenever a word is recognized,
# then move it from the word inputs array to the word matches array.
#
# Example to parse ARGV:
#
#     parse_words(ARGV, global_word_argv, global_word_list)
#
function parse_words(word_inputs, word_outputs, word_list,  i, word) {
    for (i in word_inputs) {
        if (word_inputs[i] in word_list) {
            word = word_list[word_inputs[i]]
            delete word_inputs[i]
            arr_push(word_outputs, word)
        }
    }
}

# Parse the command line ARGV inputs to recognized word outputs.
#
function parse_argv() {
    parse_words(ARGV, global_word_argv, global_word_list)
}

# Print output to the screen.
#
# This is the core output function, and the only one that
# should print anything to the screen during normal operation.
#
function print_output() {
    print words_to_s(global_num, global_num_, global_options, global_word_argv)
}

############################################################################
#
# MAIN
#
##

BEGIN{
    init()
    parse_argv()
    start_input()
}

{
    split($0, arr)
    for(i in arr) global_num[++global_num_n] = arr[i]
}

END{
    stop_input()
    print_output()
}' "$@"
