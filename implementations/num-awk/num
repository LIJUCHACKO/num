#!/bin/sh
set -euf

###
#
# Num: number utilties for mathematics and statistics.
#
# Syntax:
#
#     num [ options ] [ file ... ]
#
# Full documentation is available in the GitHub repository:
# https://github.com/numcommand/num
#
# ## Tracking
#
# Author: Joel Parker Henderson (joel@joelparkerhenderson.com)
# License: GPL, BSD, MIT
# Created: 2015-03-28
# Updated: 2015-10-26
# Version: 0.6.0
#
###

awk '

############################################################################
#
# Sysadmin
#
###

function help() {
    print "Num version 0.6.0."
    print "Copyright (C) 2015 Joel Parker Henderson."
    print "Please see http://github.com/numcommand"
    print ""
    print "The system Awk command is:"
    system("command -v awk")
    print ""
    system("awk -Wversion 2>/dev/null || awk --version")
    exit
}

############################################################################
#
# Public Functions
#
###

###
#
# All items.
#
function all(num, num_, options,  f) {
    f="all"
    if (!(f in num_)) {
        num_[f] = arr_join(num, OFS)
    }
    return num_[f]
}

function all_(  f) {
   function_metadata("all", "each", "Get all the items.")
}

###
#
# First item.
#
# Example:
#
#   1 2 4 => 1
#
function first(num, num_, options,  f) {
    f="first"
    if (!(f in num_)) {
        num_[f] = arr_first(num)
    }
    return num_[f]
}

function first_(  f) {
    function_metadata("first", "head", "Get the first item.")
}

###
#
# Last item.
#
# Example:
#
#   1 2 4 => 4
#
function last(num, num_, options,  f) {
    f="last"
    if (!(f in num_)) {
        num_[f] = arr_last(num)
    }
    return num_[f]
}

function last_(  f) {
    function_metadata("last", "tail", "Get the last item.")
}

###
#
# Number of items, a.k.a. count, length.
#
# Example:
#
#     1 2 4 => 3
#
function n(num, num_, options,  f) {
    f="n"
    if (!(f in num_)) {
        num_[f] = arr_length(num)
    }
    return num_[f]
}

function n_(  f) {
    function_metadata("n", "count length size", "Get the number of items, a.k.a. count, length, size.")
}

###
#
# Minimum value.
#
# Example:
#
#     1 2 4 => 1
#
function min(num, num_, options,  f, _min, i) {
    f="min"
    if (!(f in num_)) {
        num_[f] = arr_min_via_scan(num)  # TODO ascending/descending
    }
    return num_[f]
}

function min_(  f) {
    function_metadata("min", "minimum least lowest", "Get the minimum value, a.k.a. least, lowest.")
}

###
#
# Maximum value.
#
# Example:
#
#     1 2 4 => 4
#
function max(num, num_, options,  f, _max, i) {
    f="max"
    if (!(f in num_)) {
        num_[f] = arr_max_via_scan(num)  # TODO ascending/descending
    }
    return num_[f]
}

function max_(  f) {
    function_metadata("max", "maximum greatest highest", "Get the maximum value, a.k.a. greatest, highest.")
}

###
#
# Range, a.k.a. spread.
#
# Example:
#
#     1 2 4 => 3
#
function range(num, num_, options,  f) {
    f="range"
    if (!(f in num_)) {
        num_[f] = max(num, num_, options) - min(num, num_, options)
    }
    return num_[f]
}

function range_(  f) {
    function_metadata("range", "breadth spread", "Get the range, a.k.a. breadth, spread.")
}

###
#
# Sum, a.k.a. total.
#
# Example:
#
#     1 2 4 => 7
#
function sum(num, num_, options,  f, _sum, i) {
    f="sum"
    if (!(f in num_)) {
        _sum = 0
        for (i in num) {
            _sum += num[i]
        }
        num_[f] = _sum
    }
    return num_[f]
}

function sum_(  f) {
    function_metadata("sum", "total", "Get the sum.")
}

###
#
# Mean, a.k.a. arithmetic mean, average.
#
# Example:
#
#     1 2 4 => 2.33333
#
function mean(num, num_, options,  f) {
    f="mean"
    if (!(f in num_)) {
        if (num_["linear"]) {
          num_[f] = (max(num, num_, options) - min(num, num_, options)) / n(num, num_, options)
        } else {
          num_[f] = sum(num, num_, options) / n(num, num_, options)
        }
    }
    return num_[f]
}

function mean_(  f) {
    function_metadata("mean", "average avg", "Get the mean, a.k.a artihmetic mean, average.")
}

###
#
# Mean absolute deviation.
#
# The average distance between each value and the mean.
#
# Example:
#
#     1 2 4 => 1.11111
#
function mean_absolute_deviation(num, num_, options,  f, i, x) {
    f="mean_absolute_deviation"
    if (!(f in num_)) {
        _mean = mean(num, num_, options)
        for (i in num) x += abs(num[i] - _mean)
        num_[f] = x / n(num, num_, options)
    }
    return num_[f]
}

function mean_absolute_deviation_(  f) {
    function_metadata("mean_absolute_deviation", "mad", "Get the average distance between each value and the mean.")
}

###
#
# Meanest, i.e. the value closest to the mean.
#
# Example:
#
#     1 2 4 => 2
#
function meanest(num, num_, options,  f) {
    f="meanest"
    if (!(f in num_)) {
        num_[f] = arr_closest_value(num, mean(num, num_))
    }
    return num_[f]
}

function meanest_(  f) {
    function_metadata("meanest", "", "Get the meanest, i.e. value closest to the mean.")
}

###
#
# Median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 3
#
function median(num, num_, options,  f, _n) {
    f="median"
    if (!(f in num_)) {
        sort(num, num_, options)
        _n = n(num, num_, options)
        if (_n % 2) {
            num_[f] = num_["median_low"] = num_["median_high"] = num[(_n + 1) / 2]
        } else {
            num_["median_low"] = num[(_n / 2)]
            num_["median_high"] =  num[(_n / 2) + 1]
            num_[f] = ((num_["median_low"] + num_["median_high"]) / 2.0)
        }
    }
    return num_["median"]
}

function median_(  f) {
    function_metadata("median", "med", "Get the median.")
}

###
#
# Median-low: get the lesser median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 2
#
function median_low(num, num_, options,  f, _n) {
    f="median_low"
    if (!(f in num_)) {
        median(num, num_, options)  # n.b. median sets median_low
    }
    return num_[f]
}

function median_low_(  f) {
    function_metadata("median_low", "med_low", "Get the median that is lower a.k.a. lesser.")
}

###
#
# Median-high: get the greater median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 4
#
function median_high(num, num_, options,  f, _n) {
    f="median_high"
    if (!(f in num_)) {
        median(num, num_, options)  # n.b. median sets median_low
    }
    return num_[f]
}

function median_high_(  f) {
  function_metadata("median_high", "med_high", "Get the median that is higher a.k.a. greater.")
}

###
#
# Mode: get the mode, which may be a number, or list, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 4 => 2
#     1 1 2 4 4 => 1 4
#     1 2 3 => UNDEF
#
function mode(num, num_, options,  f) {
    f="mode"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

function mode_(  f) {
    function_metadata("mode", "", "Get the mode, which may be a value, or list, or UNDEF.")
}

###
#
# Mode-low: get the first mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 1
#     1 2 3 => UNDEF
#
function mode_low(num, num_, options,  f) {
    f="mode_low"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

function mode_low_(  f) {
    function_metadata("mode_low", "", "Get the first mode, if any, or UNDEF.")
}

###
#
# Mode-high: get the last mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 4
#     1 2 3 => UNDEF
#
function mode_high(num, num_, options,  f) {
    f="mode_high"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

function mode_high_(  f) {
    function_metadata("mode_high", "", "Get the last mode, if any, or UNDEF.")
}

###
#
# Sum of Squares, a.k.a. the sum of each deviation to the power of 2, a.k.a. SS.
#
# Example:
#
#     1 2 4 => 4.66667
#
function sum_of_squares(num, num_, options) {
    return sum_of_mean_deviation_exp(num, num_, options, 2)
}

function sum_of_squares_(  f) {
    function_metadata("sum_of_squares", "sum_squares ss", "Get the sum of squares, a.k.a. sum of each mean deviation to the power of 2.")
}

###
#
# Sum of Cubes, a.k.a. sum of each mean deviation to the power of 3.
#
# Example:
#
#     1 2 4 => 2.22222
#
function sum_of_cubes(num, num_, options,  f, _sum, _mean, i) {
    return sum_of_mean_deviation_exp(num, num_, options, 3)
}

function sum_of_cubes_(  f) {
    function_metadata("sum_of_cubes", "sum_cubes", "Get the  sum of cubes, a.k.a. sum of each mean deviation to the power of 3.")
}

###
#
# Sum of Quads, a.k.a. sum of each mean deviation to the power of 4.
#
# Example:
#
#     1 2 4 => TODO
#
function sum_of_quads(num, num_, options,  f, _sum, _mean, i) {
    return sum_of_mean_deviation_exp(num, num_, options, 4)
}

function sum_of_quads_(  f) {
    function_metadata("sum_of_quads", "sum_quads", "Get the  sum of quads, a.k.a. sum of each mean deviation to the power of 4.")
}

###
#
# Population Variance.
#
# Example:
#
#     1 2 4 => 1.55556
#
function population_variance(num, num_, options,  f) {
    return sum_of_mean_deviation_exp_over_x(num, num_, options, 2, n(num, num_, options))
}

function population_variance_(  f) {
    function_metadata("population_variance", "p_var population_second_moment_about_the_mean p_second_moment", "Get the population variance, a.k.a. sample second moment about the mean.")
}

###
#
# Sample Variance.
#
# Example:
#
#     1 2 4 => 2.33333
#
function sample_variance(num, num_, options,  f) {
    return sum_of_mean_deviation_exp_over_x(num, num_, options, 2, n(num, num_, options) - 1)
}

function sample_variance_(  f) {
    function_metadata("sample_variance", "s_var sample_second_moment_about_the_mean, s_second_moment", "Get the sample variance, a.k.a. sample second moment about the mean.")
}

###
#
# Population Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.24722
#
function population_standard_deviation(num, num_, options,  f) {
    f="population_standard_deviation"
    if (!(f in num_)) {
        num_[f] = sqrt(population_variance(num, num_, options))
    }
    return num_[f]
}

function population_standard_deviation_(  f) {
    function_metadata("population_standard_deviation", "p_st_dev p_s_d", "Get the population standard deviation.")
}

###
#
# Sample Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.52753
#
function sample_standard_deviation(num, num_, options,  f) {
    f="sample_standard_deviation"
    if (!(f in num_)) {
        num_[f] = sqrt(sample_variance(num, num_, options))
    }
    return num_[f]
}

function sample_standard_deviation_(  f) {
    function_metadata("sample_standard_deviation", "s_st_dev s_s_d", "Get the sample standard deviation")
}

###
#
# Population Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.534522
#
function population_coefficient_of_variance(num, num_, options,  f) {
    f="population_coefficient_of_variance"
    if (!(f in num_)) {
        num_[f] = population_standard_deviation(num, num_, options) / mean(num, num_, options)
    }
    return num_[f]
}

function population_coefficient_of_variance_(  f) {
    function_metadata("population_coefficient_of_variance", "p_co_var p_c_v", "Get the population coefficient of variance.")
}

###
#
# Sample Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.654654
#
function sample_coefficient_of_variance(num, num_, options,  f) {
    f="sample_coefficient_of_variance"
    if (!(f in num_)) {
        num_[f] = sample_standard_deviation(num, num_, options) / mean(num, num_, options)
    }
    return num_[f]
}

function sample_coefficient_of_variance_(  f) {
    function_metadata("sample_coefficient_of_variance", "s_co_var s_c_v", "Get the sample coefficient of variance")
}

###
#
# Population skewness
#
# Example:
#
#     1 2 4 => 0.740741
#
# A.k.a. population third moment about the mean.
#
# If skewness is greater than zero, the distribution is positively skewed.
# If it is less than zero, it is negatively skewed.
# Zero means it is symmetric.
#
# Calculation:
#
#   * Sum each value deviation from the mean cubed.
#   * Divide by the number of items.
#
function population_skewness(num, num_, options,  f) {
    return sum_of_mean_deviation_exp_over_x(num, num_, options, 3, n(num, num_, options))
}

function population_skewness_(  f) {
    function_metadata("population_skewness", "p_skew population_third_moment_about_the_mean population_third_moment p_third_moment", "Get the population skewness, a.k.a. population third moment about the mean.")
}

###
#
# Sample skewness
#
# Example:
#
#     TODO
#
# A.k.a. population third moment about the mean.
#
# Calculation:
#
#   * Sum each value deviation from the mean cubed.
#   * Divide by the number of items - 1.
#
function sample_skewness(num, num_, options,  f) {
    return sum_of_mean_deviation_exp_over_x(num, num_, options, 3, (n(num, num_, options) - 1))
}

function sample_skewness_(  f) {
    function_metadata("sample_skewness", "s_skew sample_third_moment_about_the_mean sample_third_moment s_third_moment", "Get the sample skewness, a.k.a. sample third moment about the mean.")
}

###
#
# Population kurtosis
#
# Example:
#
#     TODO
#
# A.k.a. population fourth moment about the mean.
#
# Calculation:
#
#   * Sum each value’s deviation from the mean quaded.
#   * Divide by the number of items .
#
# The kurtosis formula measures the degree of peak.
#
# Kurtosis equals 3 for a normal distribution.
#
# Kurtosis is also a nondimensional quantity.
#
# Kurtosis measures the relative peakness or flatness of a distribution,
# relative to a normal distribution.
#
#   * Positive kurtosis (peakness) is termed leptokurtic.
#   * Negative kurtosis (flatness) is termed platykurtic.
#   * In-between is termed mesokurtic.
#
function population_kurtosis(num, num_, options,  f) {
    return sum_of_mean_deviation_exp_over_x(num, num_, options, 4, n(num, num_, options))
}

function population_kurtosis_(  f) {
    function_metadata("population_kurtosis", "p_kurt population_fourth_moment_about_the_mean population_fourth_moment p_fourth_moment", "Get the kurtosis, a.k.a. population fourth moment about the mean.")
}


###
#
# Sample kurtosis
#
# Example:
#
#     TODO
#
# A.k.a. population fourth moment about the mean.
#
function sample_kurtosis(num, num_, options,  f) {
    return sum_of_mean_deviation_exp_over_x(num, num_, options, 4, n(num, num_, options) - 1)
}

function sample_kurtosis_(  f) {
    function_metadata("sample_kurtosis", "s_kurt sample_fourth_moment_about_the_mean sample_fourth_moment s_fourth_moment", "Get the kurtosis, a.k.a. sample fourth moment about the mean.")
}

###
#
# Interquartile Range, a.k.a. IQR.
#
# Example:
#
#     TODO
#
# This implemention uses the smoothing method for discrete distrubtions:
#
#   * If there are an even number of data points, then the median is no
#     single datum point. Do not include the median in either half.
#
#   * If there are (4x+1) data points, then the lower quartile is 25% of the
#     xth data value plus 75% of the (x+1)th data value; the upper quartile
#     is 75% of the (3x+1)th data point plus 25% of the (3x+2)th data point.
#
#   * If there are (4x+3) data points, then the lower quartile is 75% of the
#     (x+1)th data value plus 25% of the (x+2)th data value; the upper
#     quartile is 25% of the (3x+2)th data point plus 75% of the (3x+3)th
#     data point.
#
#   * This ensures that the median value is given its correct weight,
#     and thus quartile values change as smoothly as possible as additional
#     data points are added.
#
#   * For more see https://en.wikipedia.org/wiki/Quartile
#
function interquartile_range(num, num_, options,  f) {
    f="interquartile_range"
    if (!(f in num_)) {
        num_[f] = quartile_3(num, num_, options) - quartile_1(num, num_, options)
    }
    return num_[f]
}

function interquartile_range_(  f) {
    function_metadata("interquartile_range", "i_q_r mid_spread middle_fifty", "Get the interquartile range, a.k.a. IQR.")
}

###
#
# Quartile 0, a.k.a. Q0, 0th percentile, minimum.
#
# Example:
#
#     TODO
#
function quartile_0(num, num_, options,  f) {
    f="quartile_0"
    if (!(f in num_)) {
        num_[f] = min(num, num_, options)
    }
    return num_[f]
}

function quartile_0_(  f) {
    function_metadata("quartile_0", "q_0 0_percent", "Get the quartile 0, a.k.a. Q0, 0th percentile, minimum.")
}

###
#
# Quartile 1, a.k.a. Q1, 25th percentile, lower quartile.
#
# Example:
#
#     TODO
#
function quartile_1(num, num_, options,  f, _n, x) {
    f="quartile_1"
    if (!(f in num_)) {
        _n = n(num, num_, options)
        median(num, num_, options)
        if ((_n % 2) == 0) {
            i = (_n / 2) - 1
            num_[f] = arr_sorted_median_slice(num, 1, i)
        }
        else if ((_n % 4) == 1) {
            x = ((_n - 1) / 4)
            num_[f] = (0.25 * num[x]) + (0.75 * num[x+1])
        }
        else if ((_n % 4) == 3) {
            x = ((_n - 3) / 4)
            num_[f] = (0.75 * num[x+1]) + (0.25 * num[x+2])
        }
        else {
           num_[f] = ERROR
        }
    }
    return num_[f]
}

function quartile_1_(  f) {
    function_metadata("quartile_1", "q_1 25_percent", "Get the quartile 1, a.k.a. Q1, 25th percentile, lower quartile.")
}

###
#
# Quartile 2, a.k.a. Q2, 50th percentile, median.
#
# Example:
#
#     TODO
#
function quartile_2(num, num_, options,  f) {
    f="quartile_2"
    if (!(f in num_)) {
        num_[f] = median(num, num_, options)
    }
    return num_[f]
}

function quartile_2_(  f) {
    function_metadata("quartile_2", "q_2 50_percent", "Get the quartile 2, a.k.a. Q2, 50th percentile, median.")
}

###
#
# Quartile 3, a.k.a. Q3, 75th percentile, upper quartile.
#
# Example:
#
#     TODO
#
function quartile_3(num, num_, options,  f, _n, x) {
    f="quartile_3"
    if (!(f in num_)) {
        _n = n(num, num_, options)
        median(num, num_, options)
        if ((_n % 2) == 0) {
            i = (_n % 2) + 1
            num_[f] = arr_sorted_median_slice(num, i, _n)
        }
        else if ((_n % 4) == 1) {
            x = (_n - 1) / 4
            num_[f] = (0.75 * num[3 * x + 1]) + (0.25 * num[3 * x + 2])
        }
        else if ((_n % 4) == 3) {
            x = (_n - 3) / 4
            num_[f] = (0.25 * num[3 * x + 2]) + (0.75 * num[3 * x + 3])
        }
        else {
           num_[f] = ERROR
        }
    }
    return num_[f]
}

function quartile_3_(  f) {
    function_metadata("quartile_3", "q_3 75_percent", "Get the quartile 3, a.k.a. Q3, 75th percentile, upper quartile.")
}

###
#
# Quartile 4, a.k.a. Q4, 100th percentile, maximum.
#
# Example:
#
#     TODO
#
function quartile_4(num, num_, options,  f) {
    f="quartile_4"
    if (!(f in num_)) {
        num_[f] = max(num, num_, options)
    }
    return num_[f]
}

function quartile_4_(  f) {
    function_metadata("quartile_4", "q_4 100_percent", "Get the quartile 4, a.k.a. Q4, 100th percentile, maximum.")
}

############################################################################
#
# TRANSFORM FUNCTIONS
#
###

###
#
# Sort in place.
#
# Example:
#
#     3 1 2 => 1 2 3
#
# Caution: This implementation requires the `asort` function,
# which we believe is available in current `gawk` implementations,
# but may not be POSIX-compliant.
#
# TODO: Research if `asort` is POSIX or if there are alternatives.
#
function sort(num, num_, options,  f) {
    f="sort"
    if (num_[f] != TRUE) {
        asort(num)
        num_[f] = TRUE
    }
    return ""
}

function sort_(  f) {
    function_metadata("sort", "sort_ascending sort_asc", "Sort the values in ascending order.")
}

############################################################################
#
# MAPS
#
###

###
#
# Map: absolute value.
#
# Example:
#
#     -1 -2 -3 => 1 2 3
#
function map_absolute_value(num, num_, options,  f) {
    f="map_absolute_value"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = abs(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function map_absolute_value_(  f) {
    function_metadata("map_absolute_value", "absolute_value abs magnitude", "Map using absolute value.")
}

###
#
# Map: normalize each value to be 0 to 1.
#
# Example:
#
#     1 2 4 => 0 0.33333 1
#
function map_normalize(num, num_, options,  f, min_old, max_old, min_new, max_new, multiply, add) {
    f="map_normalize"
    if (num_[f] != TRUE) {
        min_old = min(num, num_, options)
        max_old = max(num, num_, options)
        min_new = 0
        max_new = 1
        multiply = (max_new - min_new) / (max_old - min_old)
        add = min_new - (multiply * min_old)
        for (i in num) num[i] = num[i] * multiply + add
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function map_normalize_(  f) {
    function_metadata("map_normalize", "normalize norm", "Map using normalize.")
}

###
#
# Map: round, a.k.a. nearest integer.
#
# Example:
#
#     -1.9 1.9 => -2 2
#
function map_round(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = round(num[i])
        split("",num_)
        num_[f] = TRUE
        num_["integer"] = TRUE
    }
    return ""
}

function map_round_(  f) {
    function_metadata("map_round", "round nearest_integer n_int", "Map using round, a.k.a. nearest integer.")
}

###
#
# Map: round off, a.k.a. truncate.
#
# Example:
#
#     -1.9 1.9 => -1 1
#
function map_round_off(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round_off"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = int(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function map_round_off_(  f) {
    function_metadata("map_round_off", "round_off truncate", "Map using round off, a.k.a. truncate.")
}

###
#
# Map: round up, a.k.a. ceiling.
#
# Example:
#
#     -1.9 1.9 => -1 2
#
function map_round_up(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round_up"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = ceiling(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function map_round_up_(  f) {
    function_metadata("map_round_up", "round_up ceiling", "Map using round up, a.k.a. ceiling.")
}

###
#
# Map: round down, a.k.a. floor.
#
# Example:
#
#     -1.9 1.9 => -1 2
#
function map_round_down(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round_down"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = floor(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function map_round_down_(  f) {
    function_metadata("map_round_down", "round_down floor", "Map using round down, a.k.a. floor.")
}

############################################################################
#
# MATH FUNCTIONS
#
###

###
#
# Absolute value.
#
# Examples:
#
#    abs(1) => 1
#    abs(-1) => 1
#
function abs(x) {
    if (x >= 0) { return x } else { return -x }
}

###
#
# Truncate a.k.a. round.
#
# Examples:
#
#    round(1.9) => 2
#    round(-1.9) => -2
#
function round(x) {
    return (x >= 0) ? int(x + 0.5) : int(x - 0.5)
}

###
#
# Truncate a.k.a. round off.
#
# Examples:
#
#    truncate(1.9) => 1
#    truncate(-1.9) => -1
#
function truncate(x) {
    return int(x)
}

###
#
# Ceiling a.k.a. round up.
#
# Examples:
#
#    ceiling(1.9) => 2
#    ceiling(-1.9) => -1
#
function ceiling(x,  y) {
    y = int(x)
    return (x == y) ? x : (x >= 0) ? y + 1 : y
}

###
#
# Floor a.k.a. round down.
#
# Examples:
#
#    floor(1.9) => 1
#    floor(-1.9) => -2
#
function floor(x,  y) {
    y = int(x)
    return (x == y) ? x : (x >= 0) ? y : y - 1
}

############################################################################
#
# BOOLEAN FUNCTIONS
#
###

###
#
# Is the list all unique items?
#
# Examples:
#
#    1 2 3 => TRUE
#    1 2 2 => FALSE
#
function is_unique(num, num_, options,  f, i, seen, flag) {
    f="unique"
    if (!(f in num_)) {
        flag = TRUE
        split("", seen)
        for (i in num) {
            if (num[i] in seen) {
               flag = FALSE
               break
            } else {
              seen[num[i]] = TRUE
            }
        }
        num_[f] = flag
    }
    return num_[f]
}

function is_unique_(  f) {
    function_metadata("is_unique", "", "Is the list all unique items?")
}

###
#
# Is the list sorted in ascending order?
#
# Examples:
#
#    1 2 3 => TRUE
#    3 2 1 => FALSE
#    2 2 2 => TRUE
#
# A.k.a. non-descending.
#
# Return TRUE iff each successive number is greater or equal.
#
function is_ascending(num, num_, options,  f, x, i, flag) {
    f="ascending"
    if (!(f in num_)) {
        if (num_["strictly_ascending"] == TRUE) {
            num_[f] = TRUE
        } else if (num_["descending"] == TRUE || num_["strictly_descending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] >= x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["strictly_descending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function is_ascending_(  f) {
    function_metadata("is_ascending", "is_asc", "Is the list sorted in ascending order?")
}

###
#
# Is the list sorted in strictly ascending order?
#
# Examples:
#
#    1 2 3 => TRUE
#    3 2 1 => FALSE
#    2 2 2 => FALSE
#
# This is TRUE iff each successive number is greater.
#
function is_strictly_ascending(num, num_, options,  f, x, i, flag) {
    f="strictly_ascending"
    if (!(f in num_)) {
        if (num_["descending"] == TRUE || num_["strictly_descending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] > x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["ascending"] = TRUE
                num_["desending"] = num_["strictly_desending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function is_strictly_ascending_(  f) {
    function_metadata("is_strictly_ascending", "is_strict_asc", "Is the list sorted in strictly ascending order?")
}

###
#
# Is the list sorted in descending order?
#
# Examples:
#
#    3 2 1 => TRUE
#    1 2 3 => FALSE
#    2 2 2 => TRUE
#
# A.k.a. non-ascending.
#
# Return TRUE when each successive number is lesser or equal.
#
function is_descending(num, num_, options,  f, x, i, flag) {
    f="descending"
    if (!(f in num_)) {
        if (num_["strictly_descending"] == TRUE) {
            num_[f] = TRUE
        } else if (num_["ascending"] == TRUE || num_["strictly_ascending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] <= x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
               num_["strictly_ascending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function is_descending_(  f) {
    function_metadata("is_descending", "is_desc", "Is the list sorted in descending order?")
}

###
#
# Is the list sorted in strictly descending order?
#
# Examples:
#
#    3 2 1 => TRUE
#    1 2 3 => FALSE
#    2 2 2 => FALSE
#
# Return TRUE when each successive number is lesser.
#
function is_strictly_descending(num, num_,   f, x, i, flag) {
    f="strictly_descending"
    if (!(f in num_)) {
        if ("ascending" in num) {
            num_[f] = ! num_["ascending"]
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] < x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["ascending"] = num_["strictly_ascending"] = FALSE
                num_["desending"] = TRUE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function is_strictly_descending_(  f) {
    function_metadata("is_strictly_descending", "is_strict_desc", "Is the list sorted in strictly descending order?")
}

############################################################################
#
# HELPERS
#
###

function sum_of_mean_deviation_exp(num, num_, options, exponent,  f, i, _mean, _sum) {
    f = "sum_of_mean_deviation_exp " exponent
    if (!(f in num_)) {
        _mean = mean(num, num_, options)
        for (i in num) _sum += (num[i] - _mean) ^ exponent
        num_[f] = _sum
    }
    return num_[f]
}

function sum_of_mean_deviation_exp_over_x(num, num_, options, exponent, x,  f) {
    f = "sum_of_mean_deviation_exp_over_x " exponent " " x
    if (!(f in num_)) {
        num_[f] = sum_of_mean_deviation_exp(num, num_, options, exponent) / x
    }
   return num_[f]
}

############################################################################
#
# ARRAY UTILITIES
#
###

###
#
# Dump an array, suitable for debugging.
#
# Example:
#
#     arr_dump(arr)
#     1 a
#     2 b
#     3 d
#
function arr_dump(arr) {
    for (k in arr) print k, arr[k]
}

###
#
# Is an array empty?
#
# Example:
#
#   split("", arr)
#   arr_empty(arr) => TRUE
#
# This is POSIX compatible.
#
function arr_empty(arr,  i) {
    for (i in arr) return 0
    return 1
}

###
#
# Length of an array.
#
# Example:
#
#     arr_length(1 2 4) => 3
#
# TODO: Optimize - consider using `gawk` and its `length` function.
#
function arr_length(arr,  i, k) {
    for (i in arr) k++
    return k
}

###
#
# Return the first item in an array.
#
# Example:
#
#     arr_first(1 2 4) => 1
#
function arr_first(arr) {
    return arr[1]
}

# Return the last item in an array.
#
# Example:
#
#     arr_last(1 2 4) => 4
#
function arr_last(arr) {
    return arr[arr_length(arr)]
}

###
#
# Get the minimum value, by doing a scan of the entire array.
#
# Example:
#
#     arr_min_via_scan(1 2 4) => 4
#
function arr_min_via_scan(arr,  _min) {
    _min = arr[1]
    for (i in arr) if (arr[i] < _min) _min = arr[i]
    return _min
}

###
#
# Get the maxmimum value, by doing a scan of the entire array.
#
# Example:
#
#     arr_max_via_scan(1 2 4) => 4
#
function arr_max_via_scan(arr,  _max) {
    _max = arr[1]
    for (i in arr) if (arr[i] > _max) _max = arr[i]
    return _max
}

###
#
# Get the closest value to a target value in an array.
#
# Example:
#
#    arr = 1 2 4
#    target = 2.5
#    arr_closest_value(arr, target) => 2
#
# If multiple values are equidistant to the target,
# then return the earliest index.
#
# TODO optimize when the array is already sorted,
# by using quicksort or similar divide-and-conquer.
#
function arr_closest_value(arr, target,  _closest_value, _closest_delta, _delta, x, i) {
    for (i in arr) {
        _delta = abs(arr[i] - target)
        if (_closest_delta == "" || _delta < _closest_delta) {
            _closest_value = arr[i]
            _closest_delta = _delta
        }
    }
    return _closest_value
}

###
#
# Join an array to a string, with a separator string.
#
# Example:
#
#     arr_join(1 2 4, ",") => "1,2,4"
#
function arr_join(arr, sep,  s, i) {
    s = ""
    for (i in arr) s = s arr[i] sep
    s = substr(s, 1, length(s) - length(sep))
    return s
}

###
#
# Push one item on an array stack, by using the `length` function.
#
# Example:
#
#     arr = 1 2
#     arr_push(arr, 4)
#     => arr == 1 2 4
#
function arr_push(arr, item) {
    arr[length(arr)+1] = item
}

###
#
# Calculate the median of a sorted array,
# with slice start and slice stop.
#
# Example:
#
#     arr = 1 2 4
#     arr_median(arr)
#     => 2
#
function arr_sorted_median_slice(arr, start, stop,  n, i) {
    if (start == "") start = 1
    if (stop == "") stop = arr_length(arr)
    n = 1 + stop - start
    if (n % 2) {
        i = (start - 1) + ((_n + 1) / 2)
        return arr[i]
    } else {
        i = (start - 1) + (_n / 2)
        return (arr[i] + arr[i+1]) / 2
    }
}

############################################################################
#
# DEBUG FUNCTIONS
#
##

function out(msg) {
    print msg
}

function err(msg) {
    print msg | "cat 1>&2"  # POSIX compatible
}

############################################################################
#
# INITIALIZE
#
##

###
#
# Initialize everything.
#
# This calls various `init_*` functions.
#
function init() {
    init_constants()
    init_conf()
    init_word_argv()
    init_word_list()
    function_metadata_loader()
}

###
#
# Initialize constants that we use; these are essentially like defines.
#
function init_constants() {
    FALSE = 0
    TRUE = 1
    PI = 3.141592653589797  # also atan2(0,-1)
    TODO = "TODO"
    UNDEF = "UNDEF"
    ERROR = "ERROR"
    NAN = "NAN"

    # Function kinds: a way to track what a function will do. #TODO
    FUN_KIND_CALC = "CALC"
    FUN_KIND_SORT = "SORT"
    FUN_KIND_MAP  = "MAP"
    FUN_KIND_FLAG = "FLAG"
    FUN_KIND_CONF = "CONF"
}

##
#
# Initialize the configuration dictionary.
#
function init_conf() {
    split("", global_conf)
}

###
#
# Initialize the word argv list.
#
# The word argv list holds the argv items that this script cares about.
# We keep them in order, so we can output results in order.
#
function init_word_argv() {
    split("", global_word_argv)
}

###
#
# Initialize the global word list lookup array.
#
# This is to recognize words that a user types on the command line.
#
# TODO: research if there is a better way to initialize a dictionary.
#
function init_word_list() {

    # Convention: default is sample, not population.
    global_word_list["variance"] = \
    global_word_list["var"] = \
    "sample_variance"

    # Convention: default is sample, not population.
    global_word_list["standarddeviation"] = \
    global_word_list["stdev"] = \
    global_word_list["sd"] = \
    "sample_standard_deviation"

    # Convention: default is sample, not population.
    global_word_list["coefficientofvariance"] = \
    global_word_list["covar"] = \
    global_word_list["cv"] = \
    "sample_coefficient_of_variance"

    # Convention: default is sample, not population.
    global_word_list["secondmomentaboutthemean"] = \
    global_word_list["secondmoment"] = \
    "sample_variance"

    # Convention: default is sample, not population.
    global_word_list["thirdmomentaboutthemean"] = \
    global_word_list["thirdmoment"] = \
    "sample_skewness"

    # Convention: default is sample, not population.
    global_word_list["fourthmomentaboutthemean"] = \
    global_word_list["fourthmoment"] = \
    "sample_kurtosis"

    ### Booleans

    global_word_list["isunique"] = \
    "is_unique"

    global_word_list["isascending"] = \
    global_word_list["isasc"] = \
    global_word_list["isnondescending"] = \
    global_word_list["isnondesc"] = \
    "is_ascending"

    global_word_list["isstrictlyascending"] = \
    global_word_list["isstrictasc"] = \
    "is_strictly_ascending"

    global_word_list["isdescending"] = \
    global_word_list["isdesc"] = \
    global_word_list["isnonascending"] = \
    global_word_list["isnonasc"] = \
    "is_descending"

    global_word_list["isstrictlydescending"] = \
    global_word_list["isstrictdesc"] = \
    "is_strictly_descending"

    ### Configurations

    global_word_list["outputcommaseparatedvalues"] = \
    global_word_list["outcsv"] = \
    "output_comma_separated_values"

    global_word_list["outputtabseparatedvalues"] = \
    global_word_list["outtab"] = \
    "output_tab_separated_values"

}

###
#
# Initialize the global functions kind lookup.
#
#
function init_global_fun_kind() {

    global_fun_kind["all"] = \
    global_fun_kind["first"] = \
    global_fun_kind["last"] =  \
    global_fun_kind["min"] = \
    global_fun_kind["max"] = \
    global_fun_kind["n"] = \
    global_fun_kind["range"] = \
    global_fun_kind["sum"] = \
    global_fun_kind["mean"] = \
    global_fun_kind["mean_absolute_deviation"] = \
    global_fun_kind["meanest"] = \
    global_fun_kind["median"] = \
    global_fun_kind["median_low"] = \
    global_fun_kind["median_high"] = \
    global_fun_kind["mode"] = \
    global_fun_kind["mode_low"] = \
    global_fun_kind["modehigh"] = \
    global_fun_kind["sum_of_squares"] = \
    global_fun_kind["sum_of_cubes"] = \
    global_fun_kind["population_variance"] = \
    global_fun_kind["sample_variance"] = \
    global_fun_kind["population_standard_deviation"] = \
    global_fun_kind["sample_standard_deviation"] = \
    global_fun_kind["population_coefficient_of_variance"] = \
    global_fun_kind["sample_coefficient_of_variance"] = \
    global_fun_kind["population_skewness"] = \
    global_fun_kind["sample_skewness"] = \
    global_fun_kind["population_kurtosis"] = \
    global_fun_kind["sample_kurtosis"] = \
    global_fun_kind["interquartile_range"] = \
    global_fun_kind["quartile_0"] = \
    global_fun_kind["quartile_1"] = \
    global_fun_kind["quartile_2"] = \
    global_fun_kind["quartile_3"] = \
    global_fun_kind["quartile_4"] = \
    FUN_KIND_CALC

    global_fun_kind["sort"] = \
    global_fun_kind["sort_ascending"] = \
    global_fun_kind["sort_descending"] = \
    global_fun_kind["shuffle"] = \
    FUN_KIND_SORT

    global_fun_kind["map_absolute_value"] = \
    global_fun_kind["map_normalize"] = \
    global_fun_kind["map_round"] = \
    global_fun_kind["map_round_off"] = \
    global_fun_kind["map_round_up"] = \
    global_fun_kind["map_round_down"] = \
    FUN_KIND_MAP

    global_fun_kind["is_unique"] = \
    global_fun_kind["is_ascending"] = \
    global_fun_kind["is_strictly_ascending"] = \
    global_fun_kind["is_descending"] = \
    global_fun_kind["is_strictly_descending"] = \
    global_fun_kind["is_nonascending"] = \
    global_fun_kind["is_nondescending"] = \
    FUN_KIND_FLAG

    global_fun_kind["output_comma_separated_values"] = \
    global_fun_kind["output_tab_separated_values"] = \
    FUN_KIND_CONF
}

############################################################################
#
# FUNCTION CONNECTIONS
#
###

###
#
# Initialize function metadata for a given function.
#
# Example:
#
#    function hello() {
#        print "hello world"
#    }
#
#    function hello_() {
#        function_metadata("hello", "hi hola", "Print hello world")
#    }
#
# The example creates these:
#
#    function_["hello","aliases"] = "hi hola"
#    function_["hello", "help"] = "Print hello world"
#    global_word_list["hello"] = "hello"
#    global_word_list["hi"] = "hello"
#    global_word_list["hola"] = "hello"
#
function function_metadata(name, aliases, help) {
    function_[name, "aliases"] = aliases
    function_[name, "help"] = help
    synonyms = name " " aliases
    split(synonyms, arr)
    for (i in arr) {
        synonym = arr[i]
        gsub(/_/,"", synonym)
        global_word_list[synonym] = name
    }
}

###
#
# Initialize function metadata for all our functions.
#
function function_metadata_loader() {
    all_()
    first_()
    last_()
    n_()
    min_()
    max_()
    range_()
    sum_()
    mean_()
    mean_absolute_deviation_()
    meanest_()
    median_()
    median_low_()
    median_high_()
    mode_()
    mode_low_()
    mode_high_()
    sum_of_squares_()
    sum_of_cubes_()
    sum_of_quads_()
    population_variance_()
    sample_variance_()
    population_standard_deviation_()
    sample_standard_deviation_()
    population_coefficient_of_variance_()
    sample_coefficient_of_variance_()
    population_skewness_()
    sample_skewness_()
    population_kurtosis_()
    sample_kurtosis_()
    interquartile_range_()
    quartile_0_()
    quartile_1_()
    quartile_2_()
    quartile_3_()
    quartile_4_()
    sort_()
    map_absolute_value_()
    map_normalize_()
    map_round_()
    map_round_off_()
    map_round_up_()
    map_round_down_()
    is_unique()
    is_ascending_()
    is_strictly_ascending_()
    is_descending_()
    is_strictly_descending_()
}

###
#
# Function call: given a function name, call its function.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     function_call("sum", num, num_, options)
#     => 7 (by calling the `sum` function)
#
# Note: this implementation uses if..else instead of
# any switch or case, because we want POSIX usability.
#
# TODO: Research if it is possible to simultaneously support
# gawk indirect functions, to do a function call via `@f()`.
#
function function_call(f, num, num_, options) {
    if (f == "") return ("")
    else if (f == "all") return (all(num, num_, options))
    else if (f == "first") return (first(num, num_, options))
    else if (f == "last") return (last(num, num_, options))
    else if (f == "n") return (n(num, num_, options))
    else if (f == "min") return min(num, num_, options)
    else if (f == "max") return max(num, num_, options)
    else if (f == "range") return range(num, num_, options)
    else if (f == "sum") return sum(num, num_, options)
    else if (f == "mean") return mean(num, num_, options)
    else if (f == "mean_absolute_deviation") return mean_absolute_deviation(num, num_, options)
    else if (f == "meanest") return meanest(num, num_, options)
    else if (f == "median") return median(num, num_, options)
    else if (f == "median_low") return median_low(num, num_, options)
    else if (f == "median_high") return median_high(num, num_, options)
    else if (f == "mode") return mode(num, num_, options)
    else if (f == "mode_low") return mode_low(num, num_, options)
    else if (f == "mode_high") return mode_high(num, num_, options)
    else if (f == "sum_of_squares") return sum_of_squares(num, num_, options)
    else if (f == "sum_of_cubes") return sum_of_cubes(num, num_, options)
    else if (f == "sum_of_quads") return sum_of_quads(num, num_, options)
    else if (f == "population_variance") return population_variance(num, num_, options)
    else if (f == "sample_variance") return sample_variance(num, num_, options)
    else if (f == "population_standard_deviation") return population_standard_deviation(num, num_, options)
    else if (f == "standard_deviation") return standard_deviation(num, num_, options)
    else if (f == "sample_standard_deviation") return sample_standard_deviation(num, num_, options)
    else if (f == "population_coefficient_of_variance") return population_coefficient_of_variance(num, num_, options)
    else if (f == "sample_coefficient_of_variance") return sample_coefficient_of_variance(num, num_, options)
    else if (f == "population_skewness") return population_skewness(num, num_, options)
    else if (f == "sample_skewness") return sample_skewness(num, num_, options)
    else if (f == "population_kurtosis") return population_kurtosis(num, num_, options)
    else if (f == "sample_kurtosis") return sample_kurtosis(num, num_, options)
    else if (f == "interquartile_range") return interquartile_range(num, num_, options)
    else if (f == "quartile_0") return quartile_0(num, num_, options)
    else if (f == "quartile_1") return quartile_1(num, num_, options)
    else if (f == "quartile_2") return quartile_2(num, num_, options)
    else if (f == "quartile_3") return quartile_3(num, num_, options)
    else if (f == "quartile_4") return quartile_4(num, num_, options)
    else if (f == "sort") return sort(num, num_, options)
    else if (f == "map_absolute_value") return map_absolute_value(num, num_, options)
    else if (f == "map_normalize") return map_normalize(num, num_, options)
    else if (f == "map_round") return map_round(num, num_, options)
    else if (f == "map_round_off") return map_round_off(num, num_, options)
    else if (f == "map_round_up") return map_round_up(num, num_, options)
    else if (f == "map_round_down") return map_round_down(num, num_, options)
    else if (f == "is_unique") return is_unique(num, num_, options)
    else if (f == "is_ascending") return is_ascending(num, num_, options)
    else if (f == "is_strictly_ascending") return is_strictly_ascending(num, num_, options)
    else if (f == "is_descending") return is_descending(num, num_, options)
    else if (f == "is_strictly_descending") return is_strictly_descending(num, num_, options)
    else return ""
}

############################################################################
#
# WORDS
#
###

###
#
# Given a word, set a configuration setting.
#
# Call this function for each option word a.k.a. flag,
# before any calculation happens and any work happens.
#
# This function must only set `conf` keys and values.
# This function must NOT do any calculations, work, etc.
#
function word_to_conf(word, conf) {
    if (word == "output_comma_separated_values")
        conf["output_field_separator"] = ","
    else if (word == "output_tab_separated_values")
        conf["output_field_separator"] = "\t"
    else
        return ""
}

###
#
# Given a word, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, options, "sum")
#     => "7"
#
function word_to_s(num, num_, options, word,  s) {
    s = function_call(word, num, num_, options)
    return s
}

###
#
# Given words, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, options, ("sum", "max"))
#     => "1 4"
#
function words_to_s(num, num_, options, words, sep,  word, i, s, s2) {
    s = ""
    for (i in words) {
        word = words[i]
        s2 = word_to_s(num, num_, options, word)
        if (s2 != "") s = s s2 sep
    }
    s = substr(s, 1, length(s) - length(sep))
    return s
}

############################################################################
#
# INPUT/OUTPUT
#
##

###
#
# Start receiving input.
#
# Ready the global number array for new input and new metadata.
#
function start_input() {
    clear_num_values()
    clear_num_metadata()
}

###
#
# Stop receiving input.
#
# Set any work in progress here.
#
function stop_input() {
    global_num_["n"] = global_num_n
}

function clear_num_values() {
    split("", global_num)
}

function clear_num_metadata() {
    split("", global_num_)
}

###
#
# Parse word inputs by iterating: whenever a word is recognized,
# then move it from the word inputs array to the word matches array.
#
# Example to parse ARGV:
#
#     parse_words(ARGV, global_word_argv, global_word_list)
#
function parse_words(word_inputs, word_outputs, word_list,  i, word) {
    for (i in word_inputs) {
        word = tolower(word_inputs[i])
        gsub(/[-_]/, "", word)
        if (word == "help" || word == "version" || word == "usage") {
            help()
            exit 0
        } else if (word in word_list) {
            word = word_list[word]
            delete word_inputs[i]
            arr_push(word_outputs, word)
        }
    }
}

###
#
# Parse the command line ARGV inputs to recognized word outputs.
#
function parse_argv() {
    parse_words(ARGV, global_word_argv, global_word_list)
}

###
#
# Print output to the screen.
#
# This is the core output function, and the only one that
# should print anything to the screen during normal operation.
#
function print_output() {
    print words_to_s(global_num, global_num_, global_options, global_word_argv, OFS)
}

############################################################################
#
# MAIN
#
##

BEGIN{
    init()
    parse_argv()
    start_input()
}

{
    split($0, arr)
    for(i in arr) global_num[++global_num_n] = arr[i]
}

END{
    stop_input()
    print_output()
}' "$@"
