#!/bin/sh
set -euf

###
#
# Num: number utilties for mathematics and statistics.
#
# Syntax:
#
#     num [ options ] [ file ... ]
#
# Full documentation is available in the GitHub repository:
# https://github.com/numcommand/num
#
# ## Tracking
#
# Author: Joel Parker Henderson (joel@joelparkerhenderson.com)
# License: GPL, BSD, MIT
# Created: 2015-03-28
# Updated: 2015-10-26
# Version: 0.6.0
#
###

awk '

############################################################################
#
# num-print.awk
#
###

###
#
# Print a message to stdout.
#
# Example:
#
#     out("hello")
#
function out(msg) {
    print msg
}

###
#
# Print a message to stderr.
#
# Example:
#
#     err("hello")
#
# This is purposefully POSIX compatible.
#
function err(msg) {
    print msg | "cat 1>&2"
}

############################################################################
#
# num-math.awk
#
###

###
#
# Absolute value.
#
# Examples:
#
#    abs(1) => 1
#    abs(-1) => 1
#
function abs(x) {
    if (x >= 0) { return x } else { return -x }
}

############################################################################
#
# num-round.awk
#
###

###
#
# Round to the nearest integer, a.k.a. nint().
#
# Examples:
#
#    round(1.9) => 2
#    round(-1.9) => -2
#
#    nint(1.9) => 2
#    nint(-1.9) => -2
#
function round(x) {
    return (x >= 0) ? int(x + 0.5) : int(x - 0.5)
}

# Alias
function nint(x) {
    return round(x)
}

###
#
# Round off the fractional part, a.k.a. truncate().
#
# Examples:
#
#    round_off(1.9) => 1
#    round_off(-1.9) => -1
#
#    truncate(1.9) => 1
#    truncate(-1.9) => -1
#
function round_off(x) {
    return int(x)
}

# Alias
function truncate(x) {
    return round_off(x)
}

###
#
# Round up, a.k.a. ceiling().
#
# Examples:
#
#    round_up(1.9) => 2
#    round_up(-1.9) => -1
#
#    ceiling(1.9) => 2
#    ceiling(-1.9) => -1
#
function round_up(x,  y) {
    y = int(x)
    return (x == y) ? x : (x >= 0) ? y + 1 : y
}

# Alias
function ceiling(x) {
    return round_up(x)
}

###
#
# Round down, a.k.a. floor().
#
# Examples:
#
#    round_down(1.9) => 1
#    round_down(-1.9) => -2
#
#    floor(1.9) => 1
#    floor(-1.9) => -2
#
function round_down(x,  y) {
    y = int(x)
    return (x == y) ? x : (x >= 0) ? y : y - 1
}

# Alias
function floor(x) {
    round_down(x)
}

############################################################################
#
# num-list.awk
#
###

###
#
# Number of items, a.k.a. count, length.
#
# Example:
#
#     1 2 4 => 3
#
function n(arr) {
    return length(arr)  # TODO: POSIX
}

###
#
# First item.
#
# Example:
#
#   1 2 4 => 1
#
function first(arr) {
    return arr[1]
}

###
#
# Last item.
#
# Example:
#
#   1 2 4 => 4
#
function last(arr) {
    return arr[length(arr)]  # TODO: POSIX
}

###
#
# All items.
#
# Note that this function does nothing;
# it is enable indirect function calling.
#
function all(arr) {
    return arr
}

###
#
# Minimum value.
#
# Example:
#
#     1 2 4 => 1
#
# This implementation does a scan of the entire array.
#
function min(arr,  _min, i) {
    _min = ""
    for (i in arr) {
        if (_min == "" || arr[i] < _min) {
            _min = arr[i]
        }
    }
    return _min
}

###
#
# Maximum value.
#
# Example:
#
#     1 2 4 => 4
#
# This implementation does a scan of the entire array.
#
function max(arr,  _max, i) {
    _max = ""
    for (i in arr) {
        if (_max == "" || arr[i] > _max) {
            _max = arr[i]
        }
    }
    return _max
}

###
#
# Range, a.k.a. spread.
#
# Example:
#
#     1 2 4 => 3
#
function range(arr) {
    return max(arr) - min(arr)
}

############################################################################
#
# num-shift.awk
#
###

###
#
# Shift one item from the head of a list.
#
# Example:
#
#     arr = 1 2 4
#     shift(arr, 4)
#     => 4
#     => arr == 1 2
#
# Return the item.
#
function shift(arr,  item, i) {
    len = length(arr)
    item = arr[1]
    for (i = 1; i < len; i++) arr[i] = arr[i+1]
    delete arr[len]
    return item
}

###
#
# Unshift one item onto the head of a list.
#
# Example:
#
#     arr = 1 2
#     unshift(arr, 4)
#     => 4
#     => arr == 4 1 2
#
# Return the item for chainability.
#
function unshift(arr,item,  i) {
    len = length(arr)
    for (i = 1; i < len; i++) arr[i+1] = arr[i]
    arr[1] = item
    return item
}

############################################################################
#
# num-stack.awk
#
###

###
#
# Push one item on an array list.
#
# Example:
#
#     arr = 1 2
#     push(arr, 4)
#     => 4
#     => arr == 1 2 4
#
# Return the item for chainability.
#
function push(arr, item,  i) {
    i = length(arr) + 1
    arr[i] = item
    return item
}

###
#
# Pop one item from an array list.
#
# Example:
#
#     arr = 1 2 4
#     pop(arr)
#     => 4
#     => arr == 1 2
#
# Return the item.
#
function pop(arr,  item, i) {
    i = length(arr)
    item = arr[i]
    delete arr[i]
    return item
}

############################################################################
#
# num-queue.awk
#
###

###
#
# Enqueue one item to an array queue.
#
# Example:
#
#     arr = 1 2
#     enqueue(arr, 4)
#     => 4
#     => arr == 1 2 4
#
# Return the item for chainability.
#
function enqueue(arr, item,  i) {
    i = length(arr) + 1
    arr[i] = item
    return item
}

###
#
# Dequeue one item from an array queue.
#
# Example:
#
#     arr = 1 2 4
#     dequeue(arr)
#     => 1
#     => arr == 2 4
#
# Return the item.
#
function dequeue(arr,  item, i) {
    return shift(arr)
}

############################################################################
#
# num-statistics.awk
#
###

###
#
# Sum, a.k.a. total.
#
# Example:
#
#     1 2 4 => 7
#
function sum(arr,  x) {
    for (i in arr) x += arr[i]
    return x
}

###
#
# Product.
#
# Example:
#
#     1 2 4 => 8
#
function product(arr,  x) {
    x = 1
    for (i in arr) x *= arr[i]
    return x
}

###
#
# Mean, a.k.a. arithmetic mean, average.
#
# Example:
#
#     1 2 4 => 2.33333
#
function mean(arr) {
    return sum(arr) / n(arr)
}

###
#
# Mean, with a linear list, minimum, and maximum.
#
# Example:
#
#     1 2 4 => 2.33333
#
# Requirement: the array is linear
#
function mean_with_linear_n_min_max(arr, n, min, max) {
    return min + (max - min) / n
}

###
#
# Mean absolute deviation.
#
# The average distance between each value and the mean.
#
# Example:
#
#     1 2 4 => 1.11111
#
function mean_absolute_deviation(arr,  _mean, _n, x) {
    _mean = mean(arr)
    _n = n(arr)
    for (i in arr) x += abs(arr[i] - _mean)
    return x / _n
}

###
#
# Median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 3
#
# Requirement: the array is sorted.
#
function median(arr,  _n, i) {
    _n = n(arr)
    if (_n % 2) {
        i = (_n + 1) / 2
        return arr[i]
    } else {
        i = _n / 2
        return (arr[i] + arr[i+1]) / 2.0
    }
}

###
#
# Median low: get the lesser median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 2
#
function median_low(arr,  _n, i) {
    _n = n(arr)
    if (_n % 2) {
        i = (_n + 1) / 2
    } else {
        i = _n / 2
    }
    return arr[i]
}

###
#
# Median high: get the greater median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 4
#
function median_high(arr,  _n, i) {
    _n = n(arr)
    if (_n % 2) {
        i = (_n + 1) / 2
    } else {
        i = (_n / 2) + 1
    }
    return arr[i]
}

###
#
# Sum of mean deviation exp.
#
# Example:
#
#     arr = 1 2 4
#     exponent = 3
#     sum_of_mean_deviation_exp(arr, exponent) => sum of cubes
#
# Typically useful to calculate variance, skewness, kurtosis.
#
function sum_of_mean_deviation_exp(arr, exponent,  i, _sum, _mean) {
    _mean = mean(arr)
    for (i in arr) _sum += (arr[i] - _mean) ^ exponent
    return _sum
}

############################################################################
#
# num-quartiles.awk
#
# This implemention uses the smoothing method for discrete distrubtions:
#
#   * If there are an even number of data points, then the median is no
#     single datum point. Do not include the median in either half.
#
#   * If there are (4x+1) data points, then the lower quartile is 25% of the
#     xth data value plus 75% of the (x+1)th data value; the upper quartile
#     is 75% of the (3x+1)th data point plus 25% of the (3x+2)th data point.
#
#   * If there are (4x+3) data points, then the lower quartile is 75% of the
#     (x+1)th data value plus 25% of the (x+2)th data value; the upper
#     quartile is 25% of the (3x+2)th data point plus 75% of the (3x+3)th
#     data point.
#
#   * This ensures that the median value is given its correct weight,
#     and thus quartile values change as smoothly as possible as additional
#     data points are added.
#
#   * For more see https://en.wikipedia.org/wiki/Quartile
#
###

###
#
# Interquartile Range, a.k.a. IQR.
#
# Example:
#
#     TODO
#
function interquartile_range(arr) {
    return quartile_3(arr) - quartile_1(arr)
}

###
#
# Quartile 0, a.k.a. Q0, 0th percentile, minimum.
#
# Example:
#
#     TODO
#
function quartile_0(arr) {
    return min(arr)
}

###
#
# Quartile 1, a.k.a. Q1, 25th percentile, lower quartile.
#
# Example:
#
#     TODO
#
# Requires sorted array.
#
function quartile_1(arr,  _n, q1, i, x) {
    _n = n(arr)
    if ((_n % 2) == 0) {
        i = (_n / 2) - 1
        q1 = arr_sorted_median_slice(arr, 1, i)
    } else if ((_n % 4) == 1) {
        x = ((_n - 1) / 4)
        q1 = (0.25 * arr[x]) + (0.75 * arr[x+1])
    } else if ((_n % 4) == 3) {
        x = ((_n - 3) / 4)
        q1 = (0.75 * arr[x+1]) + (0.25 * arr[x+2])
    } else {
        q1 = ""
    }
    return q1
}

###
#
# Quartile 2, a.k.a. Q2, 50th percentile, median.
#
# Example:
#
#     TODO
#
function quartile_2(arr,  f) {
    return median(arr)
}

###
#
# Quartile 3, a.k.a. Q3, 75th percentile, upper quartile.
#
# Example:
#
#     TODO
#
# Requires sorted array.
#
function quartile_3(arr,  _n, q3, i, x) {
    _n = n(arr)
    if ((_n % 2) == 0) {
        i = (_n % 2) + 1
        q3 = arr_sorted_median_slice(arr, i, _n)
    } else if ((_n % 4) == 1) {
        x = (_n - 1) / 4
        q3 = (0.75 * arr[3 * x + 1]) + (0.25 * arr[3 * x + 2])
    } else if ((_n % 4) == 3) {
        x = (_n - 3) / 4
        q3 = (0.25 * arr[3 * x + 2]) + (0.75 * arr[3 * x + 3])
    } else {
        q3 = ""
    }
    return q3
}

###
#
# Quartile 4, a.k.a. Q4, 100th percentile, maximum.
#
# Example:
#
#     TODO
#
function quartile_4(arr) {
    return max(arr)
}

############################################################################
#
# Sysadmin
#
###

function num_help() {
    print "Num version 0.6.0."
    print "Copyright (C) 2015 Joel Parker Henderson."
    print "Please see http://github.com/numcommand"
    print ""
    print "The system Awk command is:"
    system("command -v awk")
    print ""
    system("awk -Wversion 2>/dev/null || awk --version")
    exit
}

############################################################################
#
# List
#
###

###
#
# All items.
#
function num_all(num, num_, opts) {
    return arr_join(num, OFS)
}

function num_all_init() {
   function_init("all each", "Get all the items.")
}

###
#
# First item.
#
# Example:
#
#   1 2 4 => 1
#
function num_first(num, num_, opts,  f) {
    f = "num_first"
    if (!(f in num_)) num_[f] = first(num)
    return num_[f]
}

function num_first_init() {
    function_init("first head", "Get the first item.")
}

###
#
# Last item.
#
# Example:
#
#   1 2 4 => 4
#
function num_last(num, num_, opts,  f) {
    f = "num_last"
    if (!(f in num_)) num_[f] = last(num)
    return num_[f]
}

function num_last_init() {
    function_init("last tail", "Get the last item.")
}

###
#
# Number of items, a.k.a. count, length.
#
# Example:
#
#     1 2 4 => 3
#
function num_n(num, num_, opts,  f) {
    f = "num_n"
    if (!(f in num_)) num_[f] = n(num)
    return num_[f]
}

function num_n_init() {
    function_init("n count length size", "Get the number of items, a.k.a. count, length, size.")
}

###
#
# Minimum value.
#
# Example:
#
#     1 2 4 => 1
#
function num_min(num, num_, opts,  f) {
    f = "num_min"
    if (!(f in num_)) num_[f] = min(num)  # TODO optimize ascending & descending
    return num_[f]
}

function num_min_init() {
    function_init("min minimum least lowest", "Get the minimum value, a.k.a. least, lowest.")
}

###
#
# Maximum value.
#
# Example:
#
#     1 2 4 => 4
#
function num_max(num, num_, opts,  f) {
    f = "num_max"
    if (!(f in num_)) num_[f] = max(num)  # TODO optimize ascending & descending
    return num_[f]
}

function num_max_init() {
    function_init("max maximum greatest highest", "Get the maximum value, a.k.a. greatest, highest.")
}

###
#
# Range, a.k.a. spread.
#
# Example:
#
#     1 2 4 => 3
#
function num_range(num, num_, opts,  f) {
    f = "num_range"
    if (!(f in num_)) num_[f] = num_max(num, num_, opts) - num_min(num, num_, opts)
    return num_[f]
}

function num_range_init() {
    function_init("range breadth spread", "Get the range, a.k.a. breadth, spread.")
}

###
#
# Sum, a.k.a. total.
#
# Example:
#
#     1 2 4 => 7
#
function num_sum(num, num_, opts,  f, _sum, i) {
    f = "num_sum"
    if (!(f in num_)) num_[f] = sum(num)  # TODO optimize linear
    return num_[f]
}

function num_sum_init() {
    function_init("sum total", "Get the sum, a.k.a. total.")
}

###
#
# Product.
#
# Example:
#
#     1 2 4 => 8
#
function num_product(num, num_, opts,  f, _product, i) {
    f = "num_product"
    if (!(f in num_)) num_[f] = product(num)
    return num_[f]
}

function num_product_init() {
    function_init("product", "Get the product.")
}

###
#
# Mean, a.k.a. arithmetic mean, average.
#
# Example:
#
#     1 2 4 => 2.33333
#
function num_mean(num, num_, opts,  f, _min, _max, _sum, _n) {
    f = "num_mean"
    if (!(f in num_)) {
        if (num_["linear"]) {
            num_[f] = mean_with_linear_n_min_max(num, num_n(num, num_, opts), num_min(num, num_, opts), num_max(num, num_, opts))
        } else {
            num_[f] = num_sum(num, num_, opts) / num_n(num, num_, opts)
        }
    }
    return num_[f]
}

function num_mean_init() {
    function_init("mean average avg", "Get the mean, a.k.a artihmetic mean, average.")
}

###
#
# Mean absolute deviation.
#
# The average distance between each value and the mean.
#
# Example:
#
#     1 2 4 => 1.11111
#
function num_mean_absolute_deviation(num, num_, opts,  f, _n, _mean, i, x) {
    f = "num_mean_absolute_deviation"
    if (!(f in num_)) {
        _n = num_n(num, num_, opts)
        _mean = num_mean(num, num_, opts)
        for (i in num) x += abs(num[i] - _mean)
        num_[f] = x / _n
    }
    return num_[f]
}

function num_mean_absolute_deviation_init() {
    function_init("mean_absolute_deviation mad", "Get the average distance between each value and the mean.")
}

###
#
# Meanest, i.e. the value closest to the mean.
#
# Example:
#
#     1 2 4 => 2
#
function num_meanest(num, num_, opts,  f) {
    f = "num_meanest"
    if (!(f in num_)) num_[f] = arr_closest_value(num, num_mean(num, num_, opts))
    return num_[f]
}

function num_meanest_init() {
    function_init("meanest", "Get the meanest, i.e. value closest to the mean.")
}

###
#
# Median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 3
#
function num_median(num, num_, opts,  f, i, _n) {
    f = "num_median"
    if (!(f in num_)) {
        num_sort(num, num_, opts)
        _n = num_n(num, num_, opts)
        if (_n % 2) {
            i = (_n + 1) / 2
            num_[f] = num_["num_median_low"] = num_["num_median_high"] = num[i]
        } else {
            i = _n / 2
            num_["num_median_low"] = num[i]
            num_["num_median_high"] = num[i+1]
            num_[f] = (num[i] + num[i+1]) / 2.0
        }
    }
    return num_[f]
}

function num_median_init() {
    function_init("median med", "Get the median.")
}

###
#
# Median-low: get the lesser median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 2
#
function num_median_low(num, num_, opts,  f, _n) {
    f = "num_median_low"
    if (!(f in num_)) {
        num_median(num, num_, opts)  # n.b. median sets median_low
    }
    return num_[f]
}

function num_median_low_init() {
    function_init("median_low med_low", "Get the median that is lower a.k.a. lesser.")
}

###
#
# Median-high: get the greater median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 4
#
function num_median_high(num, num_, opts,  f, _n) {
    f = "num_median_high"
    if (!(f in num_)) {
        num_median(num, num_, opts)  # n.b. median sets median_low
    }
    return num_[f]
}

function num_median_high_init() {
  function_init("median_high med_high", "Get the median that is higher a.k.a. greater.")
}

###
#
# Mode: get the mode, which may be a number, or list, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 4 => 2
#     1 1 2 4 4 => 1 4
#     1 2 3 => UNDEF
#
function num_mode(num, num_, opts,  f) {
    f = "num_mode"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

function num_mode_init() {
    function_init("mode", "Get the mode, which may be a value, or list, or UNDEF.")
}

###
#
# Mode-low: get the first mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 1
#     1 2 3 => UNDEF
#
function num_mode_low(num, num_, opts,  f) {
    f = "num_mode_low"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

function num_mode_low_init() {
    function_init("mode_low", "Get the first mode, if any, or UNDEF.")
}

###
#
# Mode-high: get the last mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 4
#     1 2 3 => UNDEF
#
function num_mode_high(num, num_, opts,  f) {
    f = "num_mode_high"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

function num_mode_high_init() {
    function_init("mode_high", "Get the last mode, if any, or UNDEF.")
}

###
#
# Sum of mean deviation exp.
#
# Example:
#
#     arr = 1 2 4
#     exponent = 3
#     sum_of_mean_deviation_exp(arr, exponent) => sum of cubes
#
# Typically useful to calculate variance, skewness, kurtosis.
#
function num_sum_of_mean_deviation_exp(num, num_, opts, exponent,  i, _sum, _mean) {
    f = "num_sum_of_mean_deviation_exp " exponent
    if (!(f in num_)) {
        _mean = num_mean(num, num_, opts)
        for (i in num) _sum += (num[i] - _mean) ^ exponent
        num_[f] = _sum
    }
    return num_[f]
}

###
#
# Sum of Squares, a.k.a. the sum of each deviation to the power of 2, a.k.a. SS.
#
# Example:
#
#     1 2 4 => 4.66667
#
function num_sum_of_squares(num, num_, opts) {
    f = "num_sum_of_squares"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 2)
    return num_[f]
}

function num_sum_of_squares_init() {
    function_init("sum_of_squares sum_squares ss", "Get the sum of squares, a.k.a. sum of each mean deviation to the power of 2, a.k.a. SS")
}

###
#
# Sum of Cubes, a.k.a. sum of each mean deviation to the power of 3.
#
# Example:
#
#     1 2 4 => 2.22222
#
function num_sum_of_cubes(num, num_, opts) {
    f = "num_sum_of_cubes"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 3)
    return num_[f]
}

function num_sum_of_cubes_init() {
    function_init("sum_of_cubes sum_cubes", "Get the  sum of cubes, a.k.a. sum of each mean deviation to the power of 3.")
}

###
#
# Sum of Quads, a.k.a. sum of each mean deviation to the power of 4.
#
# Example:
#
#     1 2 4 => TODO
#
function num_sum_of_quads(num, num_, opts) {
    f = "num_sum_of_quads"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 4)
    return num_[f]
}

function num_sum_of_quads_init() {
    function_init("sum_of_quads sum_quads", "Get the  sum of quads, a.k.a. sum of each mean deviation to the power of 4.")
}

###
#
# Population Variance.
#
# Example:
#
#     1 2 4 => 1.55556
#
function num_population_variance(num, num_, opts) {
    f = "num_population_variance"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 2) / num_n(num, num_, opts)
    return num_[f]
}

function num_population_variance_init() {
    function_init("population_variance p_var population_second_moment_about_the_mean p_second_moment", "Get the population variance, a.k.a. sample second moment about the mean.")
}

###
#
# Sample Variance.
#
# Example:
#
#     1 2 4 => 2.33333
#
function num_sample_variance(num, num_, opts,  f) {
    f = "num_sample_variance"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 2) / (num_n(num, num_, opts) - 1)
    return num_[f]
}

function num_sample_variance_init() {
    function_init("sample_variance s_var sample_second_moment_about_the_mean, s_second_moment", "Get the sample variance, a.k.a. sample second moment about the mean.")
}

###
#
# Population Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.24722
#
function num_population_standard_deviation(num, num_, opts,  f) {
    f = "num_population_standard_deviation"
    if (!(f in num_)) num_[f] = sqrt(num_population_variance(num, num_, opts))
    return num_[f]
}

function num_population_standard_deviation_init() {
    function_init("population_standard_deviation p_st_dev p_s_d", "Get the population standard deviation.")
}

###
#
# Sample Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.52753
#
function num_sample_standard_deviation(num, num_, opts,  f) {
    f = "num_sample_standard_deviation"
    if (!(f in num_)) num_[f] = sqrt(num_sample_variance(num, num_, opts))
    return num_[f]
}

function num_sample_standard_deviation_init() {
    function_init("sample_standard_deviation s_st_dev s_s_d", "Get the sample standard deviation")
}

###
#
# Population Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.534522
#
function num_population_coefficient_of_variance(num, num_, opts,  f) {
    f = "num_population_coefficient_of_variance"
    if (!(f in num_)) num_[f] = num_population_standard_deviation(num, num_, opts) / num_mean(num, num_, opts)
    return num_[f]
}

function num_population_coefficient_of_variance_init() {
    function_init("population_coefficient_of_variance p_co_var p_c_v", "Get the population coefficient of variance.")
}

###
#
# Sample Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.654654
#
function num_sample_coefficient_of_variance(num, num_, opts,  f) {
    f = "num_sample_coefficient_of_variance"
    if (!(f in num_)) num_[f] = num_sample_standard_deviation(num, num_, opts) / num_mean(num, num_, opts)
    return num_[f]
}

function num_sample_coefficient_of_variance_init() {
    function_init("sample_coefficient_of_variance s_co_var s_c_v", "Get the sample coefficient of variance")
}

###
#
# Population skewness
#
# Example:
#
#     1 2 4 => 0.740741
#
# A.k.a. population third moment about the mean.
#
# If skewness is greater than zero, the distribution is positively skewed.
# If it is less than zero, it is negatively skewed.
# Zero means it is symmetric.
#
# Calculation:
#
#   * Sum each value deviation from the mean cubed.
#   * Divide by the number of items.
#
function num_population_skewness(num, num_, opts,  f) {
    f = "num_population_skewness"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 3) / num_n(num, num_, opts)
    return num_[f]
}

function num_population_skewness_init() {
    function_init("population_skewness p_skew population_third_moment_about_the_mean population_third_moment p_third_moment", "Get the population skewness, a.k.a. population third moment about the mean.")
}

###
#
# Sample skewness
#
# Example:
#
#     TODO
#
# A.k.a. population third moment about the mean.
#
# Calculation:
#
#   * Sum each value deviation from the mean cubed.
#   * Divide by the number of items - 1.
#
function num_sample_skewness(num, num_, opts,  f) {
    f = "num_sample_skewness"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 3) / (num_n(num, num_, opts) - 1)
    return num_[f]
}

function num_sample_skewness_init() {
    function_init("sample_skewness s_skew sample_third_moment_about_the_mean sample_third_moment s_third_moment", "Get the sample skewness, a.k.a. sample third moment about the mean.")
}

###
#
# Population kurtosis
#
# Example:
#
#     TODO
#
# A.k.a. population fourth moment about the mean.
#
# Calculation:
#
#   * Sum each value’s deviation from the mean quaded.
#   * Divide by the number of items .
#
# The kurtosis formula measures the degree of peak.
#
# Kurtosis equals 3 for a normal distribution.
#
# Kurtosis is also a nondimensional quantity.
#
# Kurtosis measures the relative peakness or flatness of a distribution,
# relative to a normal distribution.
#
#   * Positive kurtosis (peakness) is termed leptokurtic.
#   * Negative kurtosis (flatness) is termed platykurtic.
#   * In-between is termed mesokurtic.
#
function num_population_kurtosis(num, num_, opts,  f) {
    f = "num_population_kurtosis"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 4) / num_n(num, num_, opts)
    return num_[f]
}

function num_population_kurtosis_init() {
    function_init("population_kurtosis p_kurt population_fourth_moment_about_the_mean population_fourth_moment p_fourth_moment", "Get the kurtosis, a.k.a. population fourth moment about the mean.")
}

###
#
# Sample kurtosis
#
# Example:
#
#     TODO
#
# A.k.a. population fourth moment about the mean.
#
function num_sample_kurtosis(num, num_, opts,  f) {
    f = "num_sample_kurtosis"
    if (!(f in num_)) num_[f] = num_sum_of_mean_deviation_exp(num, num_, opts, 4) / (num_n(num, num_, opts) - 1)
    return num_[f]
}

function num_sample_kurtosis_init() {
    function_init("sample_kurtosis s_kurt sample_fourth_moment_about_the_mean sample_fourth_moment s_fourth_moment", "Get the kurtosis, a.k.a. sample fourth moment about the mean.")
}


###
#
# Interquartile Range, a.k.a. IQR.
#
# Example:
#
#     TODO
#
# This implemention uses the smoothing method for discrete distrubtions:
#
#   * If there are an even number of data points, then the median is no
#     single datum point. Do not include the median in either half.
#
#   * If there are (4x+1) data points, then the lower quartile is 25% of the
#     xth data value plus 75% of the (x+1)th data value; the upper quartile
#     is 75% of the (3x+1)th data point plus 25% of the (3x+2)th data point.
#
#   * If there are (4x+3) data points, then the lower quartile is 75% of the
#     (x+1)th data value plus 25% of the (x+2)th data value; the upper
#     quartile is 25% of the (3x+2)th data point plus 75% of the (3x+3)th
#     data point.
#
#   * This ensures that the median value is given its correct weight,
#     and thus quartile values change as smoothly as possible as additional
#     data points are added.
#
#   * For more see https://en.wikipedia.org/wiki/Quartile
#
function num_interquartile_range(num, num_, opts,  f) {
    f = "num_interquartile_range"
    if (!(f in num_)) {
        num_[f] = num_quartile_3(num, num_, opts) - num_quartile_1(num, num_, opts)
    }
    return num_[f]
}

function num_interquartile_range_init() {
    function_init("interquartile_range i_q_r mid_spread middle_fifty", "Get the interquartile range, a.k.a. IQR.")
}

###
#
# Quartile 0, a.k.a. Q0, 0th percentile, minimum.
#
# Example:
#
#     TODO
#
function num_quartile_0(num, num_, opts,  f) {
    f = "num_quartile_0"
    if (!(f in num_)) num_[f] = num_min(num, num_, opts)
    return num_[f]
}

function num_quartile_0_init() {
    function_init("quartile_0 q_0 0_percent", "Get the quartile 0, a.k.a. Q0, 0th percentile, minimum.")
}

###
#
# Quartile 1, a.k.a. Q1, 25th percentile, lower quartile.
#
# Example:
#
#     TODO
#
function num_quartile_1(num, num_, opts,  f, _n, x) {
    f = "num_quartile_1"
    if (!(f in num_)) {
        _n = num_n(num, num_, opts)
        num_median(num, num_, opts)
        if ((_n % 2) == 0) {
            i = (_n / 2) - 1
            num_[f] = arr_sorted_median_slice(num, 1, i)
        }
        else if ((_n % 4) == 1) {
            x = ((_n - 1) / 4)
            num_[f] = (0.25 * num[x]) + (0.75 * num[x+1])
        }
        else if ((_n % 4) == 3) {
            x = ((_n - 3) / 4)
            num_[f] = (0.75 * num[x+1]) + (0.25 * num[x+2])
        }
        else {
           num_[f] = ERROR
        }
    }
    return num_[f]
}

function num_quartile_1_init() {
    function_init("quartile_1 q_1 25_percent", "Get the quartile 1, a.k.a. Q1, 25th percentile, lower quartile.")
}

###
#
# Quartile 2, a.k.a. Q2, 50th percentile, median.
#
# Example:
#
#     TODO
#
function num_quartile_2(num, num_, opts,  f) {
    f = "num_quartile_2"
    if (!(f in num_)) num_[f] = num_median(num, num_, opts)
    return num_[f]
}

function num_quartile_2_init() {
    function_init("quartile_2 q_2 50_percent", "Get the quartile 2, a.k.a. Q2, 50th percentile, median.")
}

###
#
# Quartile 3, a.k.a. Q3, 75th percentile, upper quartile.
#
# Example:
#
#     TODO
#
function num_quartile_3(num, num_, opts,  f, _n, x) {
    f = "num_quartile_3"
    if (!(f in num_)) {
        _n = num_n(num, num_, opts)
        num_median(num, num_, opts)
        if ((_n % 2) == 0) {
            i = (_n % 2) + 1
            num_[f] = arr_sorted_median_slice(num, i, _n)
        }
        else if ((_n % 4) == 1) {
            x = (_n - 1) / 4
            num_[f] = (0.75 * num[3 * x + 1]) + (0.25 * num[3 * x + 2])
        }
        else if ((_n % 4) == 3) {
            x = (_n - 3) / 4
            num_[f] = (0.25 * num[3 * x + 2]) + (0.75 * num[3 * x + 3])
        }
        else {
           num_[f] = ERROR
        }
    }
    return num_[f]
}

function num_quartile_3_init() {
    function_init("quartile_3 q_3 75_percent", "Get the quartile 3, a.k.a. Q3, 75th percentile, upper quartile.")
}

###
#
# Quartile 4, a.k.a. Q4, 100th percentile, maximum.
#
# Example:
#
#     TODO
#
function num_quartile_4(num, num_, opts,  f) {
    f = "num_quartile_4"
    if (!(f in num_)) num_[f] = num_max(num, num_, opts)
    return num_[f]
}

function num_quartile_4_init() {
    function_init("quartile_4 q_4 100_percent", "Get the quartile 4, a.k.a. Q4, 100th percentile, maximum.")
}

############################################################################
#
# TRANSFORM FUNCTIONS
#
###

###
#
# Sort in place.
#
# Example:
#
#     3 1 2 => 1 2 3
#
# Caution: This implementation requires the `asort` function,
# which we believe is available in current `gawk` implementations,
# but may not be POSIX-compliant.
#
# TODO: Research if `asort` is POSIX or if there are alternatives.
#
function num_sort(num, num_, opts,  f) {
    f = "num_sort"
    if (num_[f] != TRUE) {
        asort(num)
        num_[f] = TRUE
    }
    return ""
}

function num_sort_init() {
    function_init("sort sort_ascending sort_asc", "Sort the values in ascending order.")
}

############################################################################
#
# MAPS
#
###

###
#
# Map: absolute value.
#
# Example:
#
#     -1 -2 -3 => 1 2 3
#
function num_map_absolute_value(num, num_, opts,  f) {
    f = "num_map_absolute_value"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = abs(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function num_map_absolute_value_init() {
    function_init("map_absolute_value absolute_value abs magnitude", "Map using absolute value.")
}

###
#
# Map: normalize each value to be 0 to 1.
#
# Example:
#
#     1 2 4 => 0 0.33333 1
#
function num_map_normalize(num, num_, opts,  f, min_old, max_old, min_new, max_new, multiply, add) {
    f = "num_map_normalize"
    if (num_[f] != TRUE) {
        min_old = num_min(num, num_, opts)
        max_old = num_max(num, num_, opts)
        min_new = 0
        max_new = 1
        multiply = (max_new - min_new) / (max_old - min_old)
        add = min_new - (multiply * min_old)
        for (i in num) num[i] = num[i] * multiply + add
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function num_map_normalize_init() {
    function_init("map_normalize normalize norm", "Map using normalize.")
}

###
#
# Map: round, a.k.a. nearest integer.
#
# Example:
#
#     -1.9 1.9 => -2 2
#
function num_map_round(num, num_, opts,  f) {
    if (num_["integer"] == TRUE) return ""
    f = "num_map_round"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = round(num[i])
        split("",num_)
        num_[f] = TRUE
        num_["integer"] = TRUE
    }
    return ""
}

function num_map_round_init() {
    function_init("map_round round nearest_integer n_int", "Map using round, a.k.a. nearest integer.")
}

###
#
# Map: round off, a.k.a. truncate.
#
# Example:
#
#     -1.9 1.9 => -1 1
#
function num_map_round_off(num, num_, opts,  f) {
    if (num_["integer"] == TRUE) return ""
    f = "num_map_round_off"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = round_off(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function num_map_round_off_init() {
    function_init("map_round_off round_off truncate", "Map using round off, a.k.a. truncate.")
}

###
#
# Map: round up, a.k.a. ceiling.
#
# Example:
#
#     -1.9 1.9 => -1 2
#
function num_map_round_up(num, num_, opts,  f) {
    if (num_["integer"] == TRUE) return ""
    f = "num_map_round_up"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = round_up(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function num_map_round_up_init() {
    function_init("map_round_up round_up ceiling", "Map using round up, a.k.a. ceiling.")
}

###
#
# Map: round down, a.k.a. floor.
#
# Example:
#
#     -1.9 1.9 => -1 2
#
function num_map_round_down(num, num_, opts,  f) {
    if (num_["integer"] == TRUE) return ""
    f = "num_map_round_down"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = round_down(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

function num_map_round_down_init() {
    function_init("map_round_down round_down floor", "Map using round down, a.k.a. floor.")
}


############################################################################
#
# BOOLEAN FUNCTIONS
#
###

###
#
# Is the list all unique items?
#
# Examples:
#
#    1 2 3 => TRUE
#    1 2 2 => FALSE
#
function num_is_unique(num, num_, opts,  f, i, seen, flag) {
    f = "num_unique"
    if (!(f in num_)) {
        flag = TRUE
        split("", seen)
        for (i in num) {
            if (num[i] in seen) {
               flag = FALSE
               break
            } else {
              seen[num[i]] = TRUE
            }
        }
        num_[f] = flag
    }
    return num_[f]
}

function num_is_unique_init() {
    function_init("is_unique is_uniq", "Is the list all unique items?")
}

###
#
# Is the list sorted in ascending order?
#
# Examples:
#
#    1 2 3 => TRUE
#    3 2 1 => FALSE
#    2 2 2 => TRUE
#
# A.k.a. non-descending.
#
# Return TRUE iff each successive number is greater or equal.
#
function num_is_ascending(num, num_, opts,  f, x, i, flag) {
    f = "num_ascending"
    if (!(f in num_)) {
        if (num_["strictly_ascending"] == TRUE) {
            num_[f] = TRUE
        } else if (num_["descending"] == TRUE || num_["strictly_descending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] >= x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["strictly_descending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function num_is_ascending_init() {
    function_init("is_ascending is_asc", "Is the list sorted in ascending order?")
}

###
#
# Is the list sorted in strictly ascending order?
#
# Examples:
#
#    1 2 3 => TRUE
#    3 2 1 => FALSE
#    2 2 2 => FALSE
#
# This is TRUE iff each successive number is greater.
#
function num_is_strictly_ascending(num, num_, opts,  f, x, i, flag) {
    f = "num_strictly_ascending"
    if (!(f in num_)) {
        if (num_["descending"] == TRUE || num_["strictly_descending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] > x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["ascending"] = TRUE
                num_["desending"] = num_["strictly_desending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function num_is_strictly_ascending_init() {
    function_init("is_strictly_ascending is_strict_asc", "Is the list sorted in strictly ascending order?")
}

###
#
# Is the list sorted in descending order?
#
# Examples:
#
#    3 2 1 => TRUE
#    1 2 3 => FALSE
#    2 2 2 => TRUE
#
# A.k.a. non-ascending.
#
# Return TRUE when each successive number is lesser or equal.
#
function num_is_descending(num, num_, opts,  f, x, i, flag) {
    f = "num_descending"
    if (!(f in num_)) {
        if (num_["strictly_descending"] == TRUE) {
            num_[f] = TRUE
        } else if (num_["ascending"] == TRUE || num_["strictly_ascending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] <= x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
               num_["strictly_ascending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function num_is_descending_init() {
    function_init("is_descending is_desc", "Is the list sorted in descending order?")
}

###
#
# Is the list sorted in strictly descending order?
#
# Examples:
#
#    3 2 1 => TRUE
#    1 2 3 => FALSE
#    2 2 2 => FALSE
#
# Return TRUE when each successive number is lesser.
#
function num_is_strictly_descending(num, num_,   f, x, i, flag) {
    f = "num_strictly_descending"
    if (!(f in num_)) {
        if ("ascending" in num) {
            num_[f] = ! num_["ascending"]
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] < x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["ascending"] = num_["strictly_ascending"] = FALSE
                num_["desending"] = TRUE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

function num_is_strictly_descending_init() {
    function_init("is_strictly_descending is_strict_desc", "Is the list sorted in strictly descending order?")
}

############################################################################
#
# ARRAY UTILITIES
#
###

###
#
# Dump an array, suitable for debugging.
#
# Example:
#
#     arr_dump(arr)
#     1 a
#     2 b
#     3 d
#
function arr_dump(arr) {
    for (k in arr) print k, arr[k]
}

###
#
# Is an array empty?
#
# Example:
#
#   split("", arr)
#   arr_empty(arr) => TRUE
#
# This is POSIX compatible.
#
function arr_empty(arr,  i) {
    for (i in arr) return FALSE
    return TRUE
}

###
#
# Length of an array.
#
# Example:
#
#     arr_length(1 2 4) => 3
#
# TODO: Optimize - consider using `gawk` and its `length` function.
#
function arr_length(arr,  i, k) {
    for (i in arr) k++
    return k
}

###
#
# Get the closest value to a target value in an array.
#
# Example:
#
#    arr = 1 2 4
#    target = 2.5
#    arr_closest_value(arr, target) => 2
#
# If multiple values are equidistant to the target,
# then return the earliest index.
#
# TODO optimize when the array is already sorted,
# by using quicksort or similar divide-and-conquer.
#
function arr_closest_value(arr, target,  _closest_value, _closest_delta, _delta, x, i) {
    for (i in arr) {
        _delta = abs(arr[i] - target)
        if (_closest_delta == "" || _delta < _closest_delta) {
            _closest_value = arr[i]
            _closest_delta = _delta
        }
    }
    return _closest_value
}

###
#
# Join an array to a string, with a separator string.
#
# Example:
#
#     arr_join(1 2 4, ",") => "1,2,4"
#
function arr_join(arr, sep,  s, i) {
    s = ""
    for (i in arr) s = s arr[i] sep
    s = substr(s, 1, length(s) - length(sep))
    return s
}

###
#
# Calculate the median of a sorted array,
# with slice start and slice stop.
#
# Example:
#
#     arr = 1 2 4
#     arr_median(arr)
#     => 2
#
function arr_sorted_median_slice(arr, start, stop,  n, i) {
    if (start == "") start = 1
    if (stop == "") stop = arr_length(arr)
    n = 1 + stop - start
    if (n % 2) {
        i = (start - 1) + ((_n + 1) / 2)
        return arr[i]
    } else {
        i = (start - 1) + (_n / 2)
        return (arr[i] + arr[i+1]) / 2
    }
}

############################################################################
#
# INITIALIZE
#
###

###
#
# Initialize everything.
#
# This calls various `init_*` functions.
#
function init() {
    init_constants()
    init_conf()
    init_word_argv()
    init_word_list()
    function_init_loader()
}

###
#
# Initialize constants that we use; these are essentially like defines.
#
function init_constants() {
    FALSE = 0
    TRUE = 1
    PI = 3.141592653589797  # also atan2(0,-1)
    TODO = "TODO"
    UNDEF = "UNDEF"
    ERROR = "ERROR"
    NAN = "NAN"

    # Function kinds: a way to track what a function will do. #TODO
    FUN_KIND_CALC = "CALC"
    FUN_KIND_SORT = "SORT"
    FUN_KIND_MAP  = "MAP"
    FUN_KIND_FLAG = "FLAG"
    FUN_KIND_CONF = "CONF"
}

##
#
# Initialize the configuration dictionary.
#
function init_conf() {
    split("", global_conf)
}

###
#
# Initialize the word argv list.
#
# The word argv list holds the argv items that this script cares about.
# We keep them in order, so we can output results in order.
#
function init_word_argv() {
    split("", global_word_argv)
}

###
#
# Initialize the global word list lookup array.
#
# This is to recognize words that a user types on the command line.
#
# TODO: research if there is a better way to initialize a dictionary.
#
function init_word_list() {

    # Convention: default is sample, not population.
    global_word_list["variance"] = \
    global_word_list["var"] = \
    "num_sample_variance"

    # Convention: default is sample, not population.
    global_word_list["standarddeviation"] = \
    global_word_list["stdev"] = \
    global_word_list["sd"] = \
    "num_sample_standard_deviation"

    # Convention: default is sample, not population.
    global_word_list["coefficientofvariance"] = \
    global_word_list["covar"] = \
    global_word_list["cv"] = \
    "num_sample_coefficient_of_variance"

    # Convention: default is sample, not population.
    global_word_list["secondmomentaboutthemean"] = \
    global_word_list["secondmoment"] = \
    "num_sample_variance"

    # Convention: default is sample, not population.
    global_word_list["thirdmomentaboutthemean"] = \
    global_word_list["thirdmoment"] = \
    "num_sample_skewness"

    # Convention: default is sample, not population.
    global_word_list["fourthmomentaboutthemean"] = \
    global_word_list["fourthmoment"] = \
    "num_sample_kurtosis"

    ### Booleans

    global_word_list["isunique"] = \
    "num_is_unique"

    global_word_list["isascending"] = \
    global_word_list["isasc"] = \
    global_word_list["isnondescending"] = \
    global_word_list["isnondesc"] = \
    "num_is_ascending"

    global_word_list["isstrictlyascending"] = \
    global_word_list["isstrictasc"] = \
    "num_is_strictly_ascending"

    global_word_list["isdescending"] = \
    global_word_list["isdesc"] = \
    global_word_list["isnonascending"] = \
    global_word_list["isnonasc"] = \
    "num_is_descending"

    global_word_list["isstrictlydescending"] = \
    global_word_list["isstrictdesc"] = \
    "num_is_strictly_descending"

    ### Configurations

    global_word_list["outputcommaseparatedvalues"] = \
    global_word_list["outcsv"] = \
    "num_output_comma_separated_values"

    global_word_list["outputtabseparatedvalues"] = \
    global_word_list["outtab"] = \
    "num_output_tab_separated_values"

}

###
#
# Initialize the global functions kind lookup.
#
#
function init_global_fun_kind() {

    global_fun_kind["num_all"] = \
    global_fun_kind["num_first"] = \
    global_fun_kind["num_last"] =  \
    global_fun_kind["num_min"] = \
    global_fun_kind["num_max"] = \
    global_fun_kind["num_n"] = \
    global_fun_kind["num_range"] = \
    global_fun_kind["num_sum"] = \
    global_fun_kind["num_product"] = \
    global_fun_kind["num_mean"] = \
    global_fun_kind["num_mean_absolute_deviation"] = \
    global_fun_kind["num_meanest"] = \
    global_fun_kind["num_median"] = \
    global_fun_kind["num_median_low"] = \
    global_fun_kind["num_median_high"] = \
    global_fun_kind["num_mode"] = \
    global_fun_kind["num_mode_low"] = \
    global_fun_kind["num_modehigh"] = \
    global_fun_kind["num_sum_of_squares"] = \
    global_fun_kind["num_sum_of_cubes"] = \
    global_fun_kind["num_population_variance"] = \
    global_fun_kind["num_sample_variance"] = \
    global_fun_kind["num_population_standard_deviation"] = \
    global_fun_kind["num_sample_standard_deviation"] = \
    global_fun_kind["num_population_coefficient_of_variance"] = \
    global_fun_kind["num_sample_coefficient_of_variance"] = \
    global_fun_kind["num_population_skewness"] = \
    global_fun_kind["num_sample_skewness"] = \
    global_fun_kind["num_population_kurtosis"] = \
    global_fun_kind["num_sample_kurtosis"] = \
    global_fun_kind["num_interquartile_range"] = \
    global_fun_kind["num_quartile_0"] = \
    global_fun_kind["num_quartile_1"] = \
    global_fun_kind["num_quartile_2"] = \
    global_fun_kind["num_quartile_3"] = \
    global_fun_kind["num_quartile_4"] = \
    FUN_KIND_CALC

    global_fun_kind["num_sort"] = \
    global_fun_kind["num_sort_ascending"] = \
    global_fun_kind["num_sort_descending"] = \
    global_fun_kind["num_shuffle"] = \
    FUN_KIND_SORT

    global_fun_kind["num_map_absolute_value"] = \
    global_fun_kind["num_map_normalize"] = \
    global_fun_kind["num_map_round"] = \
    global_fun_kind["num_map_round_off"] = \
    global_fun_kind["num_map_round_up"] = \
    global_fun_kind["num_map_round_down"] = \
    FUN_KIND_MAP

    global_fun_kind["num_is_unique"] = \
    global_fun_kind["num_is_ascending"] = \
    global_fun_kind["num_is_strictly_ascending"] = \
    global_fun_kind["num_is_descending"] = \
    global_fun_kind["num_is_strictly_descending"] = \
    global_fun_kind["num_is_nonascending"] = \
    global_fun_kind["num_is_nondescending"] = \
    FUN_KIND_FLAG

    global_fun_kind["num_output_comma_separated_values"] = \
    global_fun_kind["num_output_tab_separated_values"] = \
    FUN_KIND_CONF
}

############################################################################
#
# FUNCTION CONNECTIONS
#
###

###
#
# Initialize function metadata for a given function.
#
# Example:
#
#    function num_hello() {
#        print "hello world"
#    }
#
#    function num_hello_init() {
#        function_init("hello hi hola", "Print hello world")
#    }
#
# The example creates these:
#
#    function_["num_hello","names"] = "hello hi hola"
#    function_["num_hello", "help"] = "Print hello world"
#    global_word_list["hello"] = "num_hello"
#    global_word_list["hi"] = "num_hello"
#    global_word_list["hola"] = "num_hello"
#
function function_init(names, help,  f, i, name, name_list) {
    split(names, name_list)
    f = "num_" name_list[1]
    function_[f, "names"] = names
    function_[f, "help"] = help
    for (i in name_list) {
        name = name_list[i]
        gsub(/_/,"", name)
        global_word_list[name] = f
    }
}

###
#
# Initialize function metadata for all our functions.
#
function function_init_loader() {
    num_all_init()
    num_first_init()
    num_last_init()
    num_n_init()
    num_min_init()
    num_max_init()
    num_range_init()
    num_sum_init()
    num_product_init()
    num_mean_init()
    num_mean_absolute_deviation_init()
    num_meanest_init()
    num_median_init()
    num_median_low_init()
    num_median_high_init()
    num_mode_init()
    num_mode_low_init()
    num_mode_high_init()
    num_sum_of_squares_init()
    num_sum_of_cubes_init()
    num_sum_of_quads_init()
    num_population_variance_init()
    num_sample_variance_init()
    num_population_standard_deviation_init()
    num_sample_standard_deviation_init()
    num_population_coefficient_of_variance_init()
    num_sample_coefficient_of_variance_init()
    num_population_skewness_init()
    num_sample_skewness_init()
    num_population_kurtosis_init()
    num_sample_kurtosis_init()
    num_interquartile_range_init()
    num_quartile_0_init()
    num_quartile_1_init()
    num_quartile_2_init()
    num_quartile_3_init()
    num_quartile_4_init()
    num_sort_init()
    num_map_absolute_value_init()
    num_map_normalize_init()
    num_map_round_init()
    num_map_round_off_init()
    num_map_round_up_init()
    num_map_round_down_init()
    num_is_unique()
    num_is_ascending_init()
    num_is_strictly_ascending_init()
    num_is_descending_init()
    num_is_strictly_descending_init()
}

###
#
# Function call: given a function name, call its function.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     function_call("sum", num, num_, opts)
#     => 7 (by calling the `sum` function)
#
# Note: this implementation uses if..else instead of
# any switch or case, because we want POSIX usability.
#
# TODO: Research if it is possible to simultaneously support
# gawk indirect functions, to do a function call via `@f()`.
#
function function_call(f, num, num_, opts) {
    if (f == "") return ("")
    else if (f == "num_all") return num_all(num, num_, opts)
    else if (f == "num_first") return num_first(num, num_, opts)
    else if (f == "num_last") return num_last(num, num_, opts)
    else if (f == "num_n") return num_n(num, num_, opts)
    else if (f == "num_min") return num_min(num, num_, opts)
    else if (f == "num_max") return num_max(num, num_, opts)
    else if (f == "num_range") return num_range(num, num_, opts)
    else if (f == "num_sum") return num_sum(num, num_, opts)
    else if (f == "num_product") return num_product(num, num_, opts)
    else if (f == "num_mean") return num_mean(num, num_, opts)
    else if (f == "num_mean_absolute_deviation") return num_mean_absolute_deviation(num, num_, opts)
    else if (f == "num_meanest") return num_meanest(num, num_, opts)
    else if (f == "num_median") return num_median(num, num_, opts)
    else if (f == "num_median_low") return num_median_low(num, num_, opts)
    else if (f == "num_median_high") return num_median_high(num, num_, opts)
    else if (f == "num_mode") return num_mode(num, num_, opts)
    else if (f == "num_mode_low") return num_mode_low(num, num_, opts)
    else if (f == "num_mode_high") return num_mode_high(num, num_, opts)
    else if (f == "num_sum_of_squares") return num_sum_of_squares(num, num_, opts)
    else if (f == "num_sum_of_cubes") return num_sum_of_cubes(num, num_, opts)
    else if (f == "num_sum_of_quads") return num_sum_of_quads(num, num_, opts)
    else if (f == "num_population_variance") return num_population_variance(num, num_, opts)
    else if (f == "num_sample_variance") return num_sample_variance(num, num_, opts)
    else if (f == "num_population_standard_deviation") return num_population_standard_deviation(num, num_, opts)
    else if (f == "num_standard_deviation") return num_standard_deviation(num, num_, opts)
    else if (f == "num_sample_standard_deviation") return num_sample_standard_deviation(num, num_, opts)
    else if (f == "num_population_coefficient_of_variance") return num_population_coefficient_of_variance(num, num_, opts)
    else if (f == "num_sample_coefficient_of_variance") return num_sample_coefficient_of_variance(num, num_, opts)
    else if (f == "num_population_skewness") return num_population_skewness(num, num_, opts)
    else if (f == "num_sample_skewness") return num_sample_skewness(num, num_, opts)
    else if (f == "num_population_kurtosis") return num_population_kurtosis(num, num_, opts)
    else if (f == "num_sample_kurtosis") return num_sample_kurtosis(num, num_, opts)
    else if (f == "num_interquartile_range") return num_interquartile_range(num, num_, opts)
    else if (f == "num_quartile_0") return num_quartile_0(num, num_, opts)
    else if (f == "num_quartile_1") return num_quartile_1(num, num_, opts)
    else if (f == "num_quartile_2") return num_quartile_2(num, num_, opts)
    else if (f == "num_quartile_3") return num_quartile_3(num, num_, opts)
    else if (f == "num_quartile_4") return num_quartile_4(num, num_, opts)
    else if (f == "num_sort") return num_sort(num, num_, opts)
    else if (f == "num_map_absolute_value") return num_map_absolute_value(num, num_, opts)
    else if (f == "num_map_normalize") return num_map_normalize(num, num_, opts)
    else if (f == "num_map_round") return num_map_round(num, num_, opts)
    else if (f == "num_map_round_off") return num_map_round_off(num, num_, opts)
    else if (f == "num_map_round_up") return num_map_round_up(num, num_, opts)
    else if (f == "num_map_round_down") return num_map_round_down(num, num_, opts)
    else if (f == "num_is_unique") return num_is_unique(num, num_, opts)
    else if (f == "num_is_ascending") return num_is_ascending(num, num_, opts)
    else if (f == "num_is_strictly_ascending") return num_is_strictly_ascending(num, num_, opts)
    else if (f == "num_is_descending") return num_is_descending(num, num_, opts)
    else if (f == "num_is_strictly_descending") return num_is_strictly_descending(num, num_, opts)
    else return ""
}

############################################################################
#
# WORDS
#
###

###
#
# Given a word, set a configuration setting.
#
# Call this function for each option word a.k.a. flag,
# before any calculation happens and any work happens.
#
# This function must only set `conf` keys and values.
# This function must NOT do any calculations, work, etc.
#
function word_to_conf(word, conf) {
    if (word == "output_comma_separated_values")
        conf["output_field_separator"] = ","
    else if (word == "output_tab_separated_values")
        conf["output_field_separator"] = "\t"
    else
        return ""
}

###
#
# Given a word, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, opts, "sum")
#     => "7"
#
function word_to_s(num, num_, opts, word,  s) {
    s = function_call(word, num, num_, opts)
    return s
}

###
#
# Given words, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, opts, ("sum", "max"))
#     => "1 4"
#
function words_to_s(num, num_, opts, words, sep,  word, i, s, s2) {
    s = ""
    for (i in words) {
        word = words[i]
        s2 = word_to_s(num, num_, opts, word)
        if (s2 != "") s = s s2 sep
    }
    s = substr(s, 1, length(s) - length(sep))
    return s
}

############################################################################
#
# INPUT/OUTPUT
#
##

###
#
# Start receiving input.
#
# Ready the global number array for new input and new metadata.
#
function start_input() {
    clear_num_values()
    clear_num_metadata()
}

###
#
# Stop receiving input.
#
# Set any work in progress here.
#
function stop_input() {
    global_num_["n"] = global_num_n
}

function clear_num_values() {
    split("", global_num)
}

function clear_num_metadata() {
    split("", global_num_)
}

###
#
# Parse word inputs by iterating: whenever a word is recognized,
# then move it from the word inputs array to the word matches array.
#
# Example to parse ARGV:
#
#     parse_words(ARGV, global_word_argv, global_word_list)
#
function parse_words(word_inputs, word_outputs, word_list,  i, word) {
    for (i in word_inputs) {
        word = tolower(word_inputs[i])
        gsub(/[-_]/, "", word)
        if (word == "help" || word == "version" || word == "usage") {
            num_help()
            exit 0
        } else if (word in word_list) {
            word = word_list[word]
            delete word_inputs[i]
            push(word_outputs, word)
        }
    }
}

###
#
# Parse the command line ARGV inputs to recognized word outputs.
#
function parse_argv() {
    parse_words(ARGV, global_word_argv, global_word_list)
}

###
#
# Print output to the screen.
#
# This is the core output function, and the only one that
# should print anything to the screen during normal operation.
#
function print_output() {
    print words_to_s(global_num, global_num_, global_opts, global_word_argv, OFS)
}

############################################################################
#
# MAIN
#
##

BEGIN{
    init()
    parse_argv()
    start_input()
}

{
    split($0, arr)
    for(i in arr) global_num[++global_num_n] = arr[i]
}

END{
    stop_input()
    print_output()
}' "$@"
