#!/bin/sh
set -euf

##
# Num: number utilties for mathematics and statistics.
#
# Syntax:
#
#     num [ options ] [ file ... ]
#
# Full documentation is available in the GitHub repository:
# https://github.com/numcommand/num
#
# ## Tracking
#
# Author: Joel Parker Henderson (joel@joelparkerhenderson.com)
# License: GPL, BSD, MIT
# Created: 2015-03-28
# Updated: 2015-10-22
# Version: 0.3.0
##

awk '

############################################################################
#
# Sysadmin
#
##

function help() {
    print "Num version 0.4.0."
    print "Copyright (C) 2015 Joel Parker Henderson."
    print "Please see http://github.com/numcommand"
    print ""
    print "The system Awk command is:"
    system("command -v awk")
    print ""
    system("awk -Wversion 2>/dev/null || awk --version")
    exit
}

############################################################################
#
# Public Functions
#
##

# All items.
#
function all(num, num_, options,  f) {
    f="all"
    if (!(f in num_)) {
        num_[f] = arr_join(num, OFS)
    }
    return num_[f]
}

# First item.
#
# Example:
#
#   1 2 4 => 1
#
function first(num, num_, options,  f) {
    f="first"
    if (!(f in num_)) {
        num_[f] = arr_first(num)
    }
    return num_[f]
}

# Last item.
#
# Example:
#
#   1 2 4 => 4
#
function last(num, num_, options,  f) {
    f="last"
    if (!(f in num_)) {
        num_[f] = arr_last(num)
    }
    return num_[f]
}

# Number of items, a.k.a. count, length.
#
# Example:
#
#     1 2 4 => 3
#
function n(num, num_, options,  f) {
    f="n"
    if (!(f in num_)) {
        num_[f] = arr_length(num)
    }
    return num_[f]
}

# Minimum value.
#
# Example:
#
#     1 2 4 => 1
#
function min(num, num_, options,  f, _min, i) {
    f="min"
    if (!(f in num_)) {
        num_[f] = arr_min_via_scan(num)  # TODO ascending/descending
    }
    return num_[f]
}

# Maximum value.
#
# Example:
#
#     1 2 4 => 4
#
function max(num, num_, options,  f, _max, i) {
    f="max"
    if (!(f in num_)) {
        num_[f] = arr_max_via_scan(num)  # TODO ascending/descending
    }
    return num_[f]
}

# Range, a.k.a. spread.
#
# Example:
#
#     1 2 4 => 3
#
function range(num, num_, options,  f) {
    f="range"
    if (!(f in num_)) {
        num_[f] = max(num, num_, options) - min(num, num_, options)
    }
    return num_[f]
}

# Sum, a.k.a. total.
#
# Example:
#
#     1 2 4 => 7
#
function sum(num, num_, options,  f, _sum, i) {
    f="sum"
    if (!(f in num_)) {
        _sum = 0
        for (i in num) {
            _sum += num[i]
        }
        num_[f] = _sum
    }
    return num_[f]
}

# Mean, a.k.a. arithmetic mean, average.
#
# Example:
#
#     1 2 4 => 2.33333
#
function mean(num, num_, options,  f) {
    f="mean"
    if (!(f in num_)) {
        if (num_["linear"]){
          num_[f] = (max(num, num_, options) - min(num, num_, options)) / n(num, num_, options)
        } else {
          num_[f] = sum(num, num_, options) / n(num, num_, options)
        }
    }
    return num_[f]
}

# Median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 3
#
function median(num, num_, options,  f, _n) {
    f="median"
    if (!(f in num_)) {
        sort(num, num_, options)
        _n = n(num, num_, options)
        if (_n % 2) {
            num_[f] = num_["median_low"] = num_["median_high"] = num[(_n + 1) / 2]
        } else {
            num_["median_low"] = num[(_n / 2)]
            num_["median_high"] =  num[(_n / 2) + 1]
            num_[f] = ((num_["median_low"] + num_["median_high"]) / 2.0)
        }
    }
    return num_["median"]
}

# Median-low: get the lesser median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 2
#
function median_low(num, num_, options,  f, _n) {
    f="median_low"
    if (!(f in num_)) {
        median(num, num_, options)  # n.b. median sets median_low
    }
    return num_[f]
}

# Median-high: get the greater median.
#
# Example:
#
#     1 2 4 => 2
#     1 2 4 99 => 4
#
function median_high(num, num_, options,  f, _n) {
    f="median_high"
    if (!(f in num_)) {
        median(num, num_, options)  # n.b. median sets median_low
    }
    return num_[f]
}

# Mode: get the mode, which may be a number, or list, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 4 => 2
#     1 1 2 4 4 => 1 4
#     1 2 3 => UNDEF
#
function mode(num, num_, options,  f) {
    f="mode"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

# Mode-low: get the first mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 1
#     1 2 3 => UNDEF
#
function mode_low(num, num_, options,  f) {
    f="mode_low"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

# Mode-high: get the last mode, if any, or UNDEF.
#
# TODO: IMPLEMENT
#
# Examples:
#
#     1 2 2 3 => 2
#     1 1 2 4 4 => 4
#     1 2 3 => UNDEF
#
function mode_high(num, num_, options,  f) {
    f="mode_high"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

# Sum of Squares, a.k.a. the sum of the squared deviations, a.k.a. SS.
#
# Example:
#
#     1 2 4 => 4.66667
#
function sum_of_squares(num, num_, options,  f, _sum, _mean, i) {
    f="sum_of_squares"
    if (!(f in num_)) {
        _sum = 0
        _mean = mean(num, num_, options)
        for (i in num) {
            _sum += (num[i] - _mean) ** 2
        }
        num_[f] = _sum
    }
    return num_[f]
}

# Population Variance.
#
# Example:
#
#     1 2 4 => 1.55556
#
function population_variance(num, num_, options,  f) {
    f="population_variance"
    if (!(f in num_)) {
        num_[f] = sum_of_squares(num, num_, options) / n(num, num_, options)
    }
    return num_[f]
}

# Sample Variance.
#
# Example:
#
#     1 2 4 => 2.33333
#
function sample_variance(num, num_, options,  f) {
    f="sample_variance"
    if (!(f in num_)) {
        num_[f] = sum_of_squares(num, num_, options) / (n(num, num_, options) - 1)
    }
    return num_[f]
}

# Population Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.24722
#
function population_standard_deviation(num, num_, options,  f) {
    f="population_standard_deviation"
    if (!(f in num_)) {
        num_[f] = sqrt(population_variance(num, num_, options))
    }
    return num_[f]
}

# Sample Standard Deviation.
#
# Example:
#
#     1 2 4 => 1.52753
#
function sample_standard_deviation(num, num_, options,  f) {
    f="sample_standard_deviation"
    if (!(f in num_)) {
        num_[f] = sqrt(sample_variance(num, num_, options))
    }
    return num_[f]
}

# Population Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.534522
#
function population_coefficient_of_variance(num, num_, options,  f) {
    f="population_coefficient_of_variance"
    if (!(f in num_)) {
        num_[f] = population_standard_deviation(num, num_, options) / mean(num, num_, options)
    }
    return num_[f]
}

# Sample Coefficient of Variance.
#
# Example:
#
#     1 2 4 => 0.654654
#
function sample_coefficient_of_variance(num, num_, options,  f) {
    f="sample_coefficient_of_variance"
    if (!(f in num_)) {
        num_[f] = sample_standard_deviation(num, num_, options) / mean(num, num_, options)
    }
    return num_[f]
}

# Skewness
#
# Example:
#
#     TODO
#
function skewness(num, num_, options,  f, _mean, x, i) {
    f="skewness"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

# Kurtosis
#
# Example:
#
#     TODO
#
function kurtosis(num, num_, options,  f) {
    f="kurtosis"
    if (!(f in num_)) {
        num_[f] = TODO
    }
    return num_[f]
}

# Interquartile Range, a.k.a. IQR.
#
# Example:
#
#     TODO
#
# This implemention uses the smoothing method for discrete distrubtions:
#
#   * If there are an even number of data points, then the median is no
#     single datum point. Do not include the median in either half.
#
#   * If there are (4x+1) data points, then the lower quartile is 25% of the
#     xth data value plus 75% of the (x+1)th data value; the upper quartile
#     is 75% of the (3x+1)th data point plus 25% of the (3x+2)th data point.
#
#   * If there are (4x+3) data points, then the lower quartile is 75% of the
#     (x+1)th data value plus 25% of the (x+2)th data value; the upper
#     quartile is 25% of the (3x+2)th data point plus 75% of the (3x+3)th
#     data point.
#
#   * This ensures that the median value is given its correct weight,
#     and thus quartile values change as smoothly as possible as additional
#     data points are added.
#
#   * For more see https://en.wikipedia.org/wiki/Quartile
#
function interquartile_range(num, num_, options,  f) {
    f="interquartile_range"
    if (!(f in num_)) {
        num_[f] = quartile_3(num, num_, options) - quartile_1(num, num_, options)
    }
    return num_[f]
}

# Quartile 0, a.k.a. Q0, minimum, the 0th percentile.
#
# Example:
#
#     TODO
#
function quartile_0(num, num_, options,  f) {
    f="quartile_0"
    if (!(f in num_)) {
        num_[f] = min(num, num_, options)
    }
    return num_[f]
}

# Quartile 1, a.k.a. Q1, lower quartile, the 25th percentile.
#
# Example:
#
#     TODO
#
function quartile_1(num, num_, options,  f, _n, x) {
    f="quartile_1"
    if (!(f in num_)) {
        _n = n(num, num_, options)
        median(num, num_, options)
        if ((_n % 2) == 0) {
            i = (_n / 2) - 1
            num_[f] = arr_sorted_median_slice(num, 1, i)
        }
        else if ((_n % 4) == 1) {
            x = ((_n - 1) / 4)
            num_[f] = (0.25 * num[x]) + (0.75 * num[x+1])
        }
        else if ((_n % 4) == 3) {
            x = ((_n - 3) / 4)
            num_[f] = (0.75 * num[x+1]) + (0.25 * num[x+2])
        }
        else {
           num_[f] = ERROR
        }
    }
    return num_[f]
}

# Quartile 2, a.k.a. Q2, median, the 50th percentile.
#
# Example:
#
#     TODO
#
function quartile_2(num, num_, options,  f) {
    f="quartile_2"
    if (!(f in num_)) {
        num_[f] = median(num, num_, options)
    }
    return num_[f]
}

# Quartile 3, a.k.a. Q3, upper quartile, the 75th percentile.
#
# Example:
#
#     TODO
#
function quartile_3(num, num_, options,  f, _n, x) {
    f="quartile_3"
    if (!(f in num_)) {
        _n = n(num, num_, options)
        median(num, num_, options)
        if ((_n % 2) == 0) {
            i = (_n % 2) + 1
            num_[f] = arr_sorted_median_slice(num, i, _n)
        }
        else if ((_n % 4) == 1) {
            x = (_n - 1) / 4
            num_[f] = (0.75 * num[3 * x + 1]) + (0.25 * num[3 * x + 2])
        }
        else if ((_n % 4) == 3) {
            x = (_n - 3) / 4
            num_[f] = (0.25 * num[3 * x + 2]) + (0.75 * num[3 * x + 3])
        }
        else {
           num_[f] = ERROR
        }
    }
    return num_[f]
}

# Quartile 4, a.k.a. Q4, maximum, the 100th percentile.
#
# Example:
#
#     TODO
#
function quartile_4(num, num_, options,  f) {
    f="quartile_4"
    if (!(f in num_)) {
        num_[f] = max(num, num_, options)
    }
    return num_[f]
}

############################################################################
#
# TRANSFORM FUNCTIONS
#
##

# Sort in place.
#
# Example:
#
#     3 1 2 => 1 2 3
#
# Caution: This implementation requires the `asort` function,
# which we believe is available in current `gawk` implementations,
# but may not be POSIX-compliant.
#
# TODO: Research if `asort` is POSIX or if there are alternatives.
#
function sort(num, num_, options,  f) {
    f="sort"
    if (num_[f] != TRUE) {
        asort(num)
        num_[f] = TRUE
    }
    return ""
}

############################################################################
#
# MAPS
#
##

# Map: absolute value.
#
# Example:
#
#     -1 -2 -3 => 1 2 3
#
function map_absolute_value(num, num_, options,  f) {
    f="map_absolute_value"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = abs(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

# Map: round, a.k.a. nearest int.
#
# Example:
#
#     -1.9 1.9 => -2 2
#
function map_round(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = round(num[i])
        split("",num_)
        num_[f] = TRUE
        num_["integer"] = TRUE
    }
    return ""
}

# Map: round off, a.k.a. truncate.
#
# Example:
#
#     -1.9 1.9 => -1 1
#
function map_round_off(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round_off"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = int(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

# Map: round up, a.k.a. ceiling.
#
# Example:
#
#     -1.9 1.9 => -1 2
#
function map_round_up(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round_up"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = ceiling(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

# Map: round down, a.k.a. floor.
#
# Example:
#
#     -1.9 1.9 => -1 2
#
function map_round_down(num, num_, options,  f) {
    if (num_["integer"] == TRUE) return ""
    f="map_round_down"
    if (num_[f] != TRUE) {
        for (i in num) num[i] = floor(num[i])
        split("",num_)
        num_[f] = TRUE
    }
    return ""
}

############################################################################
#
# MATH FUNCTIONS
#
##

# Absolute value.
#
# Examples:
#
#    abs(1) => 1
#    abs(-1) => 1
#
function abs(x) {
    if (x >= 0) { return x } else { return -x }
}

# Truncate a.k.a. round.
#
# Examples:
#
#    round(1.9) => 2
#    round(-1.9) => -2
#
function round(x) {
    return (x >= 0) ? int(x + 0.5) : int(x - 0.5)
}

# Truncate a.k.a. round off.
#
# Examples:
#
#    truncate(1.9) => 1
#    truncate(-1.9) => -1
#
function truncate(x) {
    return int(x)
}

# Ceiling a.k.a. round up.
#
# Examples:
#
#    ceiling(1.9) => 2
#    ceiling(-1.9) => -1
#
function ceiling(x,  y) {
    y = int(x)
    return (x == y) ? x : ( x >= 0 ) ? y + 1 : y
}

# Floor a.k.a. round down.
#
# Examples:
#
#    floor(1.9) => 1
#    floor(-1.9) => -2
#
function floor(x,  y) {
    y = int(x)
    return (x == y) ? x : (x >= 0) ? y : y - 1
}

############################################################################
#
# BOOLEAN FUNCTIONS
#
##

# Is the list all unique items?
#
# Examples:
#
#    1 2 3 => TRUE
#    1 2 2 => FALSE
#
function is_unique(num, num_, options,  f, i, seen, flag) {
    f="unique"
    if (!(f in num_)) {
        flag = TRUE
        split("", seen)
        for (i in num) {
            if (num[i] in seen) {
               flag = FALSE
               break
            } else {
              seen[num[i]] = TRUE
            }
        }
        num_[f] = flag
    }
    return num_[f]
}

# Is the list sorted in ascending order?
#
# Examples:
#
#    1 2 3 => TRUE
#    3 2 1 => FALSE
#    2 2 2 => TRUE
#
# A.k.a. non-descending.
#
# Return TRUE iff each successive number is greater or equal.
#
function is_ascending(num, num_, options,  f, x, i, flag) {
    f="ascending"
    if (!(f in num_)) {
        if (num_["strictly_ascending"] == TRUE) {
            num_[f] = TRUE
        } else if (num_["descending"] == TRUE || num_["strictly_descending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] >= x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["strictly_descending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

# Is the list sorted in strictly ascending order?
#
# Examples:
#
#    1 2 3 => TRUE
#    3 2 1 => FALSE
#    2 2 2 => FALSE
#
# This is TRUE iff each successive number is greater.
#
function is_strictly_ascending(num, num_, options,  f, x, i, flag) {
    f="strictly_ascending"
    if (!(f in num_)) {
        if (num_["descending"] == TRUE || num_["strictly_descending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] > x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["ascending"] = TRUE
                num_["desending"] = num_["strictly_desending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

# Is the list sorted in descending order?
#
# Examples:
#
#    3 2 1 => TRUE
#    1 2 3 => FALSE
#    2 2 2 => TRUE
#
# A.k.a. non-ascending.
#
# Return TRUE when each successive number is lesser or equal.
#
function is_descending(num, num_, options,  f, x, i, flag) {
    f="descending"
    if (!(f in num_)) {
        if (num_["strictly_descending"] == TRUE) {
            num_[f] = TRUE
        } else if (num_["ascending"] == TRUE || num_["strictly_ascending"] == TRUE) {
            num_[f] = FALSE
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] <= x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
               num_["strictly_ascending"] = FALSE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}

# Is the list sorted in strictly descending order?
#
# Examples:
#
#    3 2 1 => TRUE
#    1 2 3 => FALSE
#    2 2 2 => FALSE
#
# Return TRUE when each successive number is lesser.
#
function is_strictly_descending(num, num_,   f, x, i, flag) {
    f="strictly_descending"
    if (!(f in num_)) {
        if ("ascending" in num) {
            num_[f] = ! num_["ascending"]
        } else {
            flag = TRUE
            for (i in num) {
                if (x == "" || num[i] < x) {
                    x = num[i]
                } else {
                    flag = FALSE
                    break
                }
            }
            if (flag == TRUE) {
                num_["ascending"] = num_["strictly_ascending"] = FALSE
                num_["desending"] = TRUE
            }
            num_[f] = flag
        }
    }
    return num_[f]
}


############################################################################
#
# ARRAY UTILITIES
#
##

# Dump an array, suitable for debugging.
#
# Example:
#
#     arr_dump(arr)
#     1 a
#     2 b
#     3 d
#
function arr_dump(arr) {
    for (k in arr) print k, arr[k]
}

# Is an array empty?
#
# Example:
#
#   split("", arr)
#   arr_empty(arr) => TRUE
#
# This is POSIX compatible.
#
function arr_empty(arr,  i) {
    for (i in arr) return 0
    return 1
}

# Length of an array.
#
# Example:
#
#     arr_length(1 2 4) => 3
#
# TODO: Optimize - consider using `gawk` and its `length` function.
#
function arr_length(arr,  i, k) {
    for (i in arr) k++
    return k
}

# Return the first item in an array.
#
# Example:
#
#     arr_first(1 2 4) => 1
#
function arr_first(arr) {
    return arr[1]
}

# Return the last item in an array.
#
# Example:
#
#     arr_last(1 2 4) => 4
#
function arr_last(arr) {
    return arr[arr_length(arr)]
}

# Get the minimum value, by doing a scan of the entire array.
#
# Example:
#
#     arr_min_via_scan(1 2 4) => 4
#
function arr_min_via_scan(arr,  _min) {
    _min = arr[1]
    for (i in arr) if (arr[i] < _min) _min = arr[i]
    return _min
}

# Get the maxmimum value, by doing a scan of the entire array.
#
# Example:
#
#     arr_max_via_scan(1 2 4) => 4
#
function arr_max_via_scan(arr,  _max) {
    _max = arr[1]
    for (i in arr) if (arr[i] > _max) _max = arr[i]
    return _max
}

# Join an array to a string, with a separator string.
#
# Example:
#
#     arr_join(1 2 4, ",") => "1,2,4"
#
function arr_join(arr, sep,  s, i) {
    s = ""
    for (i in arr) s = s arr[i] sep
    s = substr(s, 1, length(s) - length(sep))
    return s
}

# Push one item on an array stack, by using the `length` function.
#
# Example:
#
#     arr = 1 2
#     arr_push(arr, 4)
#     => arr == 1 2 4
#
function arr_push(arr, item) {
    arr[length(arr)+1] = item
}

# Calculate the median of a sorted array,
# with slice start and slice stop.
#
# Example:
#
#     arr = 1 2 4
#     arr_median(arr)
#     => 2
#
function arr_sorted_median_slice(arr, start, stop,  n, i) {
    if (start == "") start = 1
    if (stop == "") stop = arr_length(arr)
    n = 1 + stop - start
    if (n % 2) {
        i = (start - 1) + ((_n + 1) / 2)
        return arr[i]
    } else {
        i = (start - 1) + (_n / 2)
        return (arr[i] + arr[i+1]) / 2
    }
}

############################################################################
#
# DEBUG FUNCTIONS
#
##

function out(msg) {
    print msg
}

function err(msg) {
    print msg | "cat 1>&2"  # POSIX compatible
}

############################################################################
#
# INITIALIZE
#
##

# Initialize everything.
#
# This calls various `init_*` functions.
#
function init() {
    init_constants()
    init_word_argv()
    init_word_list()
}

# Initialize constants that we use; these are essentially like defines.
#
function init_constants() {
    FALSE = 0
    TRUE = 1
    PI = 3.141592653589797  # also atan2(0,-1)
    TODO = "TODO"
    UNDEF = "UNDEF"
    ERROR = "ERROR"
    NAN = "NAN"
}

# Initialize the word argv list.
#
# The word argv list holds the argv items that this script cares about.
# We keep them in order, so we can output results in order.
#
function init_word_argv() {
    split("", global_word_argv)
}

# Initialize the global word list lookup array.
#
# This is to recognize words that a user types on the command line.
#
# TODO: research if there is a better way to initialize a dictionary.
#
function init_word_list() {

    global_word_list["all"] = "all"
    global_word_list["first"] = "first"
    global_word_list["last"] = "last"

    global_word_list["n"] = \
    global_word_list["count"] = \
    global_word_list["length"] = \
    global_word_list["size"] = \
    "n"

    global_word_list["first"] = "first"
    global_word_list["last"] = "last"

    global_word_list["min"] = \
    global_word_list["minimum"] = \
    "min"

    global_word_list["max"] = \
    global_word_list["maximum"] = \
    "max"

    global_word_list["range"] = \
    global_word_list["spread"] = \
    "range"

    global_word_list["sum"] = \
    global_word_list["total"] = \
    "sum"

    global_word_list["mean"] = \
    global_word_list["average"] = \
    global_word_list["avg"] = \
    "mean"

    global_word_list["median"] = \
    global_word_list["med"] = \
    "median"

    global_word_list["medianlow"] = \
    global_word_list["medlow"] = \
    "median_low"

    global_word_list["medianhigh"] = \
    global_word_list["medhigh"] = \
    "median_high"

    global_word_list["mode"] = "mode"
    global_word_list["modelow"] = "mode_low"
    global_word_list["modehigh"] = "mode_high"

    global_word_list["sumofsquares"] = \
    global_word_list["sumsquares"] = \
    global_word_list["ss"] = \
    "sum_of_squares"

    # Convention: default is sample, not population.
    global_word_list["variance"] = \
    global_word_list["var"] = \
    "sample_variance"

    global_word_list["populationvariance"] = \
    global_word_list["pvariance"] = \
    global_word_list["pvar"] = \
    "population_variance"

    global_word_list["samplevariance"] = \
    global_word_list["svariance"] = \
    global_word_list["svar"] = \
    "sample_variance"

    # Convention: default is sample, not population.
    global_word_list["standarddeviation"] = \
    global_word_list["stdev"] = \
    global_word_list["sd"] = \
    "sample_standard_deviation"

    global_word_list["populationstandarddeviation"] = \
    global_word_list["pstdev"] = \
    global_word_list["psd"] = \
    "population_standard_deviation"

    global_word_list["samplestandarddeviation"] = \
    global_word_list["sstdev"] = \
    global_word_list["ssd"] = \
    "sample_standard_deviation"

    # Convention: default is sample, not population.
    global_word_list["coefficientofvariance"] = \
    global_word_list["covar"] = \
    global_word_list["cv"] = \
    "sample_coefficient_of_variance"

    global_word_list["populationcoefficientofvariance"] = \
    global_word_list["pcovar"] = \
    global_word_list["pcv"] = \
    "population_coefficient_of_variance"

    global_word_list["samplecoefficientofvariance"] = \
    global_word_list["scovar"] = \
    global_word_list["scv"] = \
    "sample_coefficient_of_variance"

    global_word_list["skewness"] = global_word_list["skew"] = "skewness"
    global_word_list["kurtosis"] = global_word_list["kurt"] = "kurtosis"

    global_word_list["interquartilerange"] = \
    global_word_list["iqr"] = \
    global_word_list["midspread"] = \
    global_word_list["middlefifty"] = \
    "interquartile_range"

    global_word_list["quartile0"] = global_word_list["q0"] = "quartile_0"
    global_word_list["quartile1"] = global_word_list["q1"] = "quartile_1"
    global_word_list["quartile2"] = global_word_list["q2"] = "quartile_2"
    global_word_list["quartile3"] = global_word_list["q3"] = "quartile_3"
    global_word_list["quartile4"] = global_word_list["q4"] = "quartile_4"

    ### Transforms

    global_word_list["sort"] = "sort"

    ### Maps

    global_word_list["absolutevalue"] = \
    global_word_list["abs"] = \
    "map_absolute_value"

    global_word_list["round"] = \
    "map_round"

    global_word_list["roundoff"] = \
    global_word_list["truncate"] = \
    "map_round_off"

    global_word_list["roundup"] = \
    global_word_list["ceiling"] = \
    "map_round_up"

    global_word_list["rounddown"] = \
    global_word_list["floor"] = \
    "map_round_down"

    ### Booleans

    global_word_list["isunique"] = \
    "is_unique"

    global_word_list["isascending"] = \
    global_word_list["isasc"] = \
    global_word_list["isnondescending"] = \
    global_word_list["isnondesc"] = \
    "is_ascending"

    global_word_list["isstrictlyascending"] = \
    global_word_list["isstrictasc"] = \
    "is_strictly_ascending"

    global_word_list["isdescending"] = \
    global_word_list["isdesc"] = \
    global_word_list["isnonascending"] = \
    global_word_list["isnonasc"] = \
    "is_descending"

    global_word_list["isstrictlydescending"] = \
    global_word_list["isstrictdesc"] = \
    "is_strictly_descending"

}

############################################################################
#
# WORDS
#
##

# Given a word, call its function.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_function(num, num_, "sum")
#     => 7 (by calling the `sum` function)
#
# Note: this implementation uses if..else instead of
# any switch or case, because we want POSIX usability.
#
# TODO: Is there a way to shorten this function,
# perhaps by reflection on the word and function name?
#
function word_to_function(num, num_, options, word) {
    if (word == "all")
        return (all(num, num_, options))
    else if (word == "first")
        return (first(num, num_, options))
    else if (word == "last")
        return (last(num, num_, options))
    else if (word == "n")
        return (n(num, num_, options))
    else if (word == "min")
        return min(num, num_, options)
    else if (word == "max")
        return max(num, num_, options)
    else if (word == "range")
        return range(num, num_, options)
    else if (word == "sum")
         return sum(num, num_, options)
    else if (word == "mean")
        return mean(num, num_, options)
    else if (word == "median")
        return median(num, num_, options)
    else if (word == "median_low")
        return median_low(num, num_, options)
    else if (word == "median_high")
        return median_high(num, num_, options)
    else if (word == "mode")
        return mode(num, num_, options)
    else if (word == "mode_low")
        return mode_low(num, num_, options)
    else if (word == "mode_high")
        return mode_high(num, num_, options)
    else if (word == "sum_of_squares")
        return sum_of_squares(num, num_, options)
    else if (word == "population_variance")
        return population_variance(num, num_, options)
    else if (word == "sample_variance")
        return sample_variance(num, num_, options)
    else if (word == "population_standard_deviation")
        return population_standard_deviation(num, num_, options)
    else if (word == "standard_deviation")
        return standard_deviation(num, num_, options)
    else if (word == "sample_standard_deviation")
        return sample_standard_deviation(num, num_, options)
    else if (word == "population_coefficient_of_variance")
        return population_coefficient_of_variance(num, num_, options)
    else if (word == "sample_coefficient_of_variance")
        return sample_coefficient_of_variance(num, num_, options)
    else if (word == "skewness")
        return skewness(num, num_, options)
    else if (word == "kurtosis")
        return kurtosis(num, num_, options)
    else if (word == "interquartile_range")
        return interquartile_range(num, num_, options)
    else if (word == "quartile_0")
        return quartile_0(num, num_, options)
    else if (word == "quartile_1")
        return quartile_1(num, num_, options)
    else if (word == "quartile_2")
        return quartile_2(num, num_, options)
    else if (word == "quartile_3")
        return quartile_3(num, num_, options)
    else if (word == "quartile_4")
        return quartile_4(num, num_, options)
    else if (word == "sort")
        return sort(num, num_, options)
    else if (word == "map_absolute_value")
        return map_absolute_value(num, num_, options)
    else if (word == "map_round")
        return map_round(num, num_, options)
    else if (word == "map_round_off")
        return map_round_off(num, num_, options)
    else if (word == "map_round_up")
        return map_round_up(num, num_, options)
    else if (word == "map_round_down")
        return map_round_down(num, num_, options)
    else if (word == "is_unique")
        return is_unique(num, num_, options)
    else if (word == "is_ascending")
        return is_ascending(num, num_, options)
    else if (word == "is_strictly_ascending")
        return is_strictly_ascending(num, num_, options)
    else if (word == "is_descending")
        return is_descending(num, num_, options)
    else if (word == "is_strictly_descending")
        return is_strictly_descending(num, num_, options)
    else
        return ""
}

# Given a word, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, options, "sum")
#     => "7"
#
function word_to_s(num, num_, options, word,  s) {
    s = word_to_function(num, num_, options, word)
    return s
}

# Given words, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, options, ("sum", "max"))
#     => "1 4"
#
function words_to_s(num, num_, options, words, sep,  word, i, s, s2) {
    s = ""
    for (i in words) {
        word = words[i]
        s2 = word_to_s(num, num_, options, word)
        if (s2 != "") s = s s2 sep
    }
    s = substr(s, 1, length(s) - length(sep))
    return s
}

############################################################################
#
# INPUT/OUTPUT
#
##

# Start receiving input.
#
# Ready the global number array for new input and new metadata.
#
function start_input() {
    clear_num_values()
    clear_num_metadata()
}

# Stop receiving input.
#
# Set any work in progress here.
#
function stop_input() {
    global_num_["n"] = global_num_n
}

function clear_num_values() {
    split("", global_num)
}

function clear_num_metadata() {
    split("", global_num_)
}

# Parse word inputs by iterating: whenever a word is recognized,
# then move it from the word inputs array to the word matches array.
#
# Example to parse ARGV:
#
#     parse_words(ARGV, global_word_argv, global_word_list)
#
function parse_words(word_inputs, word_outputs, word_list,  i, word) {
    for (i in word_inputs) {
        word = tolower(word_inputs[i])
        gsub(/[-_]/, "", word)
        if (word == "help" || word == "version" || word == "usage") {
            help()
            exit 0
        } else if (word in word_list) {
            word = word_list[word]
            delete word_inputs[i]
            arr_push(word_outputs, word)
        }
    }
}

# Parse the command line ARGV inputs to recognized word outputs.
#
function parse_argv() {
    parse_words(ARGV, global_word_argv, global_word_list)
}

# Print output to the screen.
#
# This is the core output function, and the only one that
# should print anything to the screen during normal operation.
#
function print_output() {
    print words_to_s(global_num, global_num_, global_options, global_word_argv)
}

############################################################################
#
# MAIN
#
##

BEGIN{
    init()
    parse_argv()
    start_input()
}

{
    split($0, arr)
    for(i in arr) global_num[++global_num_n] = arr[i]
}

END{
    stop_input()
    print_output()
}' "$@"
