#!/bin/sh
set -euf

###
#
# Num: number utilties for mathematics and statistics.
#
# Syntax:
#
#     num [ options ] [ file ... ]
#
# Full documentation is available in the GitHub repository:
# https://github.com/numcommand/num
#
# ## Tracking
#
# Author: Joel Parker Henderson (joel@joelparkerhenderson.com)
# License: GPL, BSD, MIT
# Created: 2015-03-28
# Updated: 2015-10-01
# Version: 0.8.0
#
###

###
#
# To run this for testing and debugging, try using gawk with flags:
#
#     gawk --posix --lint
#
# To concatenate the include files:
#
#     awk 'FNR==1 && NR!=1 {print ""}{print}' \
#     $(sed -n 's/@include "\(.*\)"/\1/p' num.awk) > ~/tmp/include
#
###
awk '

@include "num.awk"

###
#
# All items.
#
#     num_all(1 2 4) => "1 2 4"
#
###

function num_all(arr) {
    return num_arr_join(arr, OFS)
}

function num_all_(num, num_, opts) {
    f = "num_all"
    if (!(f in num_)) num_[f] = num_all(num)
    return num_[f]
}

function num_all_init() {
   function_init("all each", "Get all the items.")
}

############################################################################
#
# INITIALIZE
#
###

###
#
# Initialize everything.
#
# This calls various `init_*` functions.
#
function init() {
    #init_lint()
    init_constants()
    init_conf()
    init_word_argv()
    init_word_list()
    function_manager_init()
}

###
#
# Initialize constants that we use; these are essentially like defines.
#
function init_constants() {
    FALSE = 0
    TRUE = 1
    PI = 3.141592653589797  # also atan2(0,-1)
    TODO = "TODO"
    UNDEF = "UNDEF"
    ERROR = "ERROR"
    NAN = "NAN"

    # Function kinds: a way to track what a function will do. #TODO
    FUN_KIND_CALC = "CALC"
    FUN_KIND_SORT = "SORT"
    FUN_KIND_MAP  = "MAP"
    FUN_KIND_FLAG = "FLAG"
    FUN_KIND_CONF = "CONF"

    # Feature detection. Currently this script requires Gawk.
    AWK_HAS_ASORT = TRUE
    AWK_HAS_LENGTH = TRUE
}

##
#
# Initialize the configuration dictionary.
#
function init_conf() {
    split("", global_conf)
}

###
#
# Initialize the word argv list.
#
# The word argv list holds the argv items that this script cares about.
# We keep them in order, so we can output results in order.
#
function init_word_argv() {
    split("", global_word_argv)
}

###
#
# Initialize the global word list lookup array.
#
# This is to recognize words that a user types on the command line.
#
# TODO: research if there is a better way to initialize a dictionary.
#
function init_word_list() {

    # Convention: default is sample, not population.
    global_word_list["secondmomentaboutthemean"] = \
    global_word_list["secondmoment"] = \
    "num_sample_variance"

    # Convention: default is sample, not population.
    global_word_list["thirdmomentaboutthemean"] = \
    global_word_list["thirdmoment"] = \
    "num_sample_skewness"

    # Convention: default is sample, not population.
    global_word_list["fourthmomentaboutthemean"] = \
    global_word_list["fourthmoment"] = \
    "num_sample_kurtosis"

    ### Booleans

    global_word_list["isunique"] = \
    "num_is_unique"

    global_word_list["isascending"] = \
    global_word_list["isasc"] = \
    global_word_list["isnondescending"] = \
    global_word_list["isnondesc"] = \
    "num_is_ascending"

    global_word_list["isstrictlyascending"] = \
    global_word_list["isstrictasc"] = \
    "num_is_strictly_ascending"

    global_word_list["isdescending"] = \
    global_word_list["isdesc"] = \
    global_word_list["isnonascending"] = \
    global_word_list["isnonasc"] = \
    "num_is_descending"

    global_word_list["isstrictlydescending"] = \
    global_word_list["isstrictdesc"] = \
    "num_is_strictly_descending"

    ### Configurations

    global_word_list["outputcommaseparatedvalues"] = \
    global_word_list["outcsv"] = \
    "num_output_comma_separated_values"

    global_word_list["outputtabseparatedvalues"] = \
    global_word_list["outtab"] = \
    "num_output_tab_separated_values"

}

############################################################################
#
# FUNCTION CONNECTIONS
#
###

###
#
# Initialize function metadata for a given function.
#
# Example:
#
#    function num_hello() {
#        print "hello world"
#    }
#
#    function num_hello_init() {
#        function_init("hello hi hola", "Print hello world")
#    }
#
# The example creates these:
#
#    function_["num_hello","names"] = "hello hi hola"
#    function_["num_hello", "help"] = "Print hello world"
#    global_word_list["hello"] = "num_hello"
#    global_word_list["hi"] = "num_hello"
#    global_word_list["hola"] = "num_hello"
#
function function_init(names, help,  f, i, name, name_list) {
    split(names, name_list)
    f = "num_" name_list[1]
    function_[f, "names"] = names
    function_[f, "help"] = help
    for (i in name_list) {
        name = name_list[i]
        gsub(/_/,"", name)
        global_word_list[name] = f
    }
}


############################################################################
#
# WORDS
#
###

###
#
# Given a word, set a configuration setting.
#
# Call this function for each option word a.k.a. flag,
# before any calculation happens and any work happens.
#
# This function must only set `conf` keys and values.
# This function must NOT do any calculations, work, etc.
#
function word_to_conf(word, conf) {
    if (word == "output_comma_separated_values")
        conf["output_field_separator"] = ","
    else if (word == "output_tab_separated_values")
        conf["output_field_separator"] = "\t"
    else
        return ""
}

###
#
# Given a word, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, opts, "sum")
#     => "7"
#
function word_to_s(num, num_, opts, word,  s) {
    s = function_manager_call(word, num, num_, opts)
    return s
}

###
#
# Given words, return the result as a string.
#
# Example:
#
#     num = 1 2 4
#     num_ = []
#     word_to_s(num, opts, ("sum", "max"))
#     => "1 4"
#
function words_to_s(num, num_, opts, words, sep,  word, i, s, s2) {
    s = ""
    for (i in words) {
        word = words[i]
        s2 = word_to_s(num, num_, opts, word)
        if (s2 != "") s = s s2 sep
    }
    s = substr(s, 1, length(s) - length(sep))
    return s
}

############################################################################
#
# INPUT/OUTPUT
#
##

###
#
# Start receiving input.
#
# Ready the global number array for new input and new metadata.
#
function start_input() {
    clear_num_values()
    clear_num_metadata()
}

###
#
# Stop receiving input.
#
# Set any work in progress here.
#
function stop_input() {
    global_num_["n"] = global_num_n
}

function clear_num_values() {
    split("", global_num)
}

function clear_num_metadata() {
    split("", global_num_)
}

###
#
# Parse word inputs by iterating: whenever a word is recognized,
# then move it from the word inputs array to the word matches array.
#
# Example to parse ARGV:
#
#     parse_words(ARGV, global_word_argv, global_word_list)
#
function parse_words(word_inputs, word_outputs, word_list,  i, word) {
    for (i in word_inputs) {
        word = tolower(word_inputs[i])
        gsub(/[-_]/, "", word)
        if (word == "help" || word == "version" || word == "usage") {
            num_help()
            exit 0
        } else if (word in word_list) {
            word = word_list[word]
            delete word_inputs[i]
            num_push(word_outputs, word)
        }
    }
}

###
#
# Parse the command line ARGV inputs to recognized word outputs.
#
function parse_argv() {
    parse_words(ARGV, global_word_argv, global_word_list)
}

###
#
# Print output to the screen.
#
# This is the core output function, and the only one that
# should print anything to the screen during normal operation.
#
function print_output() {
    print words_to_s(global_num, global_num_, global_opts, global_word_argv, OFS)
}

############################################################################
#
# MAIN
#
##

BEGIN{
    init()
    parse_argv()
    start_input()
}

{
    split($0, _arr)
    for(i in _arr) global_num[++global_num_n] = _arr[i]
}

END{
    stop_input()
    print_output()
}' "$@"
